// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Stmt node implementation.
// @PENGUINLIONG
#pragma once
#include "node/reg.hpp"

typedef Reference<struct StmtPatternCapture> StmtPatternCaptureRef;
typedef Reference<struct StmtPatternHead> StmtPatternHeadRef;
typedef Reference<struct StmtPatternTail> StmtPatternTailRef;
typedef Reference<struct StmtNop> StmtNopRef;
typedef Reference<struct StmtBlock> StmtBlockRef;
typedef Reference<struct StmtConditionalBranch> StmtConditionalBranchRef;
typedef Reference<struct StmtLoop> StmtLoopRef;
typedef Reference<struct StmtConditionalLoop> StmtConditionalLoopRef;
typedef Reference<struct StmtReturn> StmtReturnRef;
typedef Reference<struct StmtLoopMerge> StmtLoopMergeRef;
typedef Reference<struct StmtLoopContinue> StmtLoopContinueRef;
typedef Reference<struct StmtLoopBackEdge> StmtLoopBackEdgeRef;
typedef Reference<struct StmtRangedLoop> StmtRangedLoopRef;
typedef Reference<struct StmtStore> StmtStoreRef;

struct StmtPatternCapture : public Stmt {
  static const StmtOp OP = L_STMT_OP_PATTERN_CAPTURE;
  StmtRef captured;

  inline StmtPatternCapture(
    const StmtRef& captured
  ) : Stmt(L_STMT_OP_PATTERN_CAPTURE), captured(captured) {
    liong::assert(captured != nullptr);
  }
  inline StmtPatternCapture() : Stmt(L_STMT_OP_PATTERN_CAPTURE) {}

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(captured);
  }
};

struct StmtPatternHead : public Stmt {
  static const StmtOp OP = L_STMT_OP_PATTERN_HEAD;
  StmtRef inner;

  inline StmtPatternHead(
    const StmtRef& inner
  ) : Stmt(L_STMT_OP_PATTERN_HEAD), inner(inner) {
    liong::assert(inner != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(inner);
  }
};

struct StmtPatternTail : public Stmt {
  static const StmtOp OP = L_STMT_OP_PATTERN_TAIL;
  StmtRef inner;

  inline StmtPatternTail(
    const StmtRef& inner
  ) : Stmt(L_STMT_OP_PATTERN_TAIL), inner(inner) {
    liong::assert(inner != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(inner);
  }
};

struct StmtNop : public Stmt {
  static const StmtOp OP = L_STMT_OP_NOP;

  inline StmtNop(
  ) : Stmt(L_STMT_OP_NOP) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtBlock : public Stmt {
  static const StmtOp OP = L_STMT_OP_BLOCK;
  std::vector<StmtRef> stmts;

  inline StmtBlock(
    const std::vector<StmtRef>& stmts
  ) : Stmt(L_STMT_OP_BLOCK), stmts(stmts) {
    for (const auto& x : stmts) { liong::assert(x != nullptr); }
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    for (const auto& x : stmts) { drain->push(x); }
  }
};

struct StmtConditionalBranch : public Stmt {
  static const StmtOp OP = L_STMT_OP_CONDITIONAL_BRANCH;
  ExprRef cond;
  StmtRef then_block;
  StmtRef else_block;

  inline StmtConditionalBranch(
    const ExprRef& cond,
    const StmtRef& then_block,
    const StmtRef& else_block
  ) : Stmt(L_STMT_OP_CONDITIONAL_BRANCH), cond(cond), then_block(then_block), else_block(else_block) {
    liong::assert(cond != nullptr);
    liong::assert(then_block != nullptr);
    liong::assert(else_block != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(cond);
    drain->push(then_block);
    drain->push(else_block);
  }
};

struct StmtLoop : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP;
  StmtRef body_block;
  StmtRef continue_block;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoop(
    const StmtRef& body_block,
    const StmtRef& continue_block,
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP), body_block(body_block), continue_block(continue_block), handle(handle) {
    liong::assert(body_block != nullptr);
    liong::assert(continue_block != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(body_block);
    drain->push(continue_block);
  }
};

struct StmtConditionalLoop : public Stmt {
  static const StmtOp OP = L_STMT_OP_CONDITIONAL_LOOP;
  ExprRef cond;
  StmtRef body_block;
  StmtRef continue_block;
  std::shared_ptr<uint8_t> handle;

  inline StmtConditionalLoop(
    const ExprRef& cond,
    const StmtRef& body_block,
    const StmtRef& continue_block,
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_CONDITIONAL_LOOP), cond(cond), body_block(body_block), continue_block(continue_block), handle(handle) {
    liong::assert(cond != nullptr);
    liong::assert(body_block != nullptr);
    liong::assert(continue_block != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(cond);
    drain->push(body_block);
    drain->push(continue_block);
  }
};

struct StmtReturn : public Stmt {
  static const StmtOp OP = L_STMT_OP_RETURN;

  inline StmtReturn(
  ) : Stmt(L_STMT_OP_RETURN) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtLoopMerge : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_MERGE;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoopMerge(
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP_MERGE), handle(handle) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtLoopContinue : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_CONTINUE;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoopContinue(
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP_CONTINUE), handle(handle) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtLoopBackEdge : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_BACK_EDGE;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoopBackEdge(
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP_BACK_EDGE), handle(handle) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtRangedLoop : public Stmt {
  static const StmtOp OP = L_STMT_OP_RANGED_LOOP;
  StmtRef body_block;
  MemoryRef itervar;

  inline StmtRangedLoop(
    const StmtRef& body_block,
    const MemoryRef& itervar
  ) : Stmt(L_STMT_OP_RANGED_LOOP), body_block(body_block), itervar(itervar) {
    liong::assert(body_block != nullptr);
    liong::assert(itervar != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(body_block);
    drain->push(itervar);
  }
};

struct StmtStore : public Stmt {
  static const StmtOp OP = L_STMT_OP_STORE;
  MemoryRef dst_ptr;
  ExprRef value;

  inline StmtStore(
    const MemoryRef& dst_ptr,
    const ExprRef& value
  ) : Stmt(L_STMT_OP_STORE), dst_ptr(dst_ptr), value(value) {
    liong::assert(dst_ptr != nullptr);
    liong::assert(value != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(dst_ptr);
    drain->push(value);
  }
};
