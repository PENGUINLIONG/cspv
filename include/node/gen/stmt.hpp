// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Stmt node implementation.
// @PENGUINLIONG
#pragma once
#include "node/reg.hpp"

struct StmtNop : public Stmt {
  static const StmtOp OP = L_STMT_OP_NOP;

  inline StmtNop(
  ) : Stmt(L_STMT_OP_NOP) {
  }
};

struct StmtBlock : public Stmt {
  static const StmtOp OP = L_STMT_OP_BLOCK;
  std::vector<NodeRef<Stmt>> stmts;

  inline StmtBlock(
    const std::vector<NodeRef<Stmt>>& stmts
  ) : Stmt(L_STMT_OP_BLOCK), stmts(stmts) {
    for (const auto& x : stmts) { liong::assert(x != nullptr); }
  }
};

struct StmtConditionalBranch : public Stmt {
  static const StmtOp OP = L_STMT_OP_CONDITIONAL_BRANCH;
  NodeRef<Expr> cond;
  NodeRef<Stmt> then_block;
  NodeRef<Stmt> else_block;

  inline StmtConditionalBranch(
    const NodeRef<Expr>& cond,
    const NodeRef<Stmt>& then_block,
    const NodeRef<Stmt>& else_block
  ) : Stmt(L_STMT_OP_CONDITIONAL_BRANCH), cond(cond), then_block(then_block), else_block(else_block) {
    liong::assert(cond != nullptr);
    liong::assert(then_block != nullptr);
    liong::assert(else_block != nullptr);
  }
};

struct StmtIfThenElse : public Stmt {
  static const StmtOp OP = L_STMT_OP_IF_THEN_ELSE;
  NodeRef<Stmt> body_block;

  inline StmtIfThenElse(
    const NodeRef<Stmt>& body_block
  ) : Stmt(L_STMT_OP_IF_THEN_ELSE), body_block(body_block) {
    liong::assert(body_block != nullptr);
  }
};

struct StmtLoop : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP;
  NodeRef<Stmt> body_block;
  NodeRef<Stmt> continue_block;

  inline StmtLoop(
    const NodeRef<Stmt>& body_block,
    const NodeRef<Stmt>& continue_block
  ) : Stmt(L_STMT_OP_LOOP), body_block(body_block), continue_block(continue_block) {
    liong::assert(body_block != nullptr);
    liong::assert(continue_block != nullptr);
  }
};

struct StmtReturn : public Stmt {
  static const StmtOp OP = L_STMT_OP_RETURN;

  inline StmtReturn(
  ) : Stmt(L_STMT_OP_RETURN) {
  }
};

struct StmtIfThenElseMerge : public Stmt {
  static const StmtOp OP = L_STMT_OP_IF_THEN_ELSE_MERGE;

  inline StmtIfThenElseMerge(
  ) : Stmt(L_STMT_OP_IF_THEN_ELSE_MERGE) {
  }
};

struct StmtLoopMerge : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_MERGE;

  inline StmtLoopMerge(
  ) : Stmt(L_STMT_OP_LOOP_MERGE) {
  }
};

struct StmtLoopContinue : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_CONTINUE;

  inline StmtLoopContinue(
  ) : Stmt(L_STMT_OP_LOOP_CONTINUE) {
  }
};

struct StmtLoopBackEdge : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_BACK_EDGE;

  inline StmtLoopBackEdge(
  ) : Stmt(L_STMT_OP_LOOP_BACK_EDGE) {
  }
};

struct StmtRangedLoop : public Stmt {
  static const StmtOp OP = L_STMT_OP_RANGED_LOOP;
  NodeRef<Stmt> body_block;
  NodeRef<Memory> itervar;
  NodeRef<Expr> begin;
  NodeRef<Expr> end;
  NodeRef<Expr> stride;

  inline StmtRangedLoop(
    const NodeRef<Stmt>& body_block,
    const NodeRef<Memory>& itervar,
    const NodeRef<Expr>& begin,
    const NodeRef<Expr>& end,
    const NodeRef<Expr>& stride
  ) : Stmt(L_STMT_OP_RANGED_LOOP), body_block(body_block), itervar(itervar), begin(begin), end(end), stride(stride) {
    liong::assert(body_block != nullptr);
    liong::assert(itervar != nullptr);
    liong::assert(begin != nullptr);
    liong::assert(end != nullptr);
    liong::assert(stride != nullptr);
  }
};

struct StmtStore : public Stmt {
  static const StmtOp OP = L_STMT_OP_STORE;
  NodeRef<Memory> dst_ptr;
  NodeRef<Expr> value;

  inline StmtStore(
    const NodeRef<Memory>& dst_ptr,
    const NodeRef<Expr>& value
  ) : Stmt(L_STMT_OP_STORE), dst_ptr(dst_ptr), value(value) {
    liong::assert(dst_ptr != nullptr);
    liong::assert(value != nullptr);
  }
};

typedef NodeRef<Stmt> StmtRef;
typedef NodeRef<StmtNop> StmtNopRef;
typedef NodeRef<StmtBlock> StmtBlockRef;
typedef NodeRef<StmtConditionalBranch> StmtConditionalBranchRef;
typedef NodeRef<StmtIfThenElse> StmtIfThenElseRef;
typedef NodeRef<StmtLoop> StmtLoopRef;
typedef NodeRef<StmtReturn> StmtReturnRef;
typedef NodeRef<StmtIfThenElseMerge> StmtIfThenElseMergeRef;
typedef NodeRef<StmtLoopMerge> StmtLoopMergeRef;
typedef NodeRef<StmtLoopContinue> StmtLoopContinueRef;
typedef NodeRef<StmtLoopBackEdge> StmtLoopBackEdgeRef;
typedef NodeRef<StmtRangedLoop> StmtRangedLoopRef;
typedef NodeRef<StmtStore> StmtStoreRef;
