// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Stmt node implementation.
// @PENGUINLIONG
#pragma once
#include "node/reg.hpp"

typedef Reference<struct StmtPatternCapture> StmtPatternCaptureRef;
typedef Reference<struct StmtPatternHead> StmtPatternHeadRef;
typedef Reference<struct StmtPatternTail> StmtPatternTailRef;
typedef Reference<struct StmtNop> StmtNopRef;
typedef Reference<struct StmtBlock> StmtBlockRef;
typedef Reference<struct StmtConditionalBranch> StmtConditionalBranchRef;
typedef Reference<struct StmtLoop> StmtLoopRef;
typedef Reference<struct StmtConditionalLoop> StmtConditionalLoopRef;
typedef Reference<struct StmtReturn> StmtReturnRef;
typedef Reference<struct StmtLoopMerge> StmtLoopMergeRef;
typedef Reference<struct StmtLoopContinue> StmtLoopContinueRef;
typedef Reference<struct StmtLoopBackEdge> StmtLoopBackEdgeRef;
typedef Reference<struct StmtRangedLoop> StmtRangedLoopRef;
typedef Reference<struct StmtStore> StmtStoreRef;

struct StmtPatternCapture : public Stmt {
  static const StmtOp OP = L_STMT_OP_PATTERN_CAPTURE;
  StmtRef captured;

  inline StmtPatternCapture(
    const StmtRef& captured
  ) : Stmt(L_STMT_OP_PATTERN_CAPTURE), captured(captured) {
    liong::assert(captured != nullptr);
  }
  inline StmtPatternCapture() : Stmt(L_STMT_OP_PATTERN_CAPTURE) {}

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtPatternCapture>()) { return false; }
    const auto& b2_ = b_->as<StmtPatternCapture>();
    if (!captured->structured_eq(b2_.captured)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(captured);
  }
};

struct StmtPatternHead : public Stmt {
  static const StmtOp OP = L_STMT_OP_PATTERN_HEAD;
  StmtRef inner;

  inline StmtPatternHead(
    const StmtRef& inner
  ) : Stmt(L_STMT_OP_PATTERN_HEAD), inner(inner) {
    liong::assert(inner != nullptr);
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtPatternHead>()) { return false; }
    const auto& b2_ = b_->as<StmtPatternHead>();
    if (!inner->structured_eq(b2_.inner)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(inner);
  }
};

struct StmtPatternTail : public Stmt {
  static const StmtOp OP = L_STMT_OP_PATTERN_TAIL;
  StmtRef inner;

  inline StmtPatternTail(
    const StmtRef& inner
  ) : Stmt(L_STMT_OP_PATTERN_TAIL), inner(inner) {
    liong::assert(inner != nullptr);
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtPatternTail>()) { return false; }
    const auto& b2_ = b_->as<StmtPatternTail>();
    if (!inner->structured_eq(b2_.inner)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(inner);
  }
};

struct StmtNop : public Stmt {
  static const StmtOp OP = L_STMT_OP_NOP;

  inline StmtNop(
  ) : Stmt(L_STMT_OP_NOP) {
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtNop>()) { return false; }
    const auto& b2_ = b_->as<StmtNop>();
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtBlock : public Stmt {
  static const StmtOp OP = L_STMT_OP_BLOCK;
  std::vector<StmtRef> stmts;

  inline StmtBlock(
    const std::vector<StmtRef>& stmts
  ) : Stmt(L_STMT_OP_BLOCK), stmts(stmts) {
    for (const auto& x : stmts) { liong::assert(x != nullptr); }
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtBlock>()) { return false; }
    const auto& b2_ = b_->as<StmtBlock>();
    if (stmts.size() != b2_.stmts.size()) { return false; }
    for (size_t i = 0; i < stmts.size(); ++i) {
      if (!stmts.at(i)->structured_eq(b2_.stmts.at(i))) { return false; }
    }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    for (const auto& x : stmts) { drain->push(x); }
  }
};

struct StmtConditionalBranch : public Stmt {
  static const StmtOp OP = L_STMT_OP_CONDITIONAL_BRANCH;
  ExprRef cond;
  StmtRef then_block;
  StmtRef else_block;

  inline StmtConditionalBranch(
    const ExprRef& cond,
    const StmtRef& then_block,
    const StmtRef& else_block
  ) : Stmt(L_STMT_OP_CONDITIONAL_BRANCH), cond(cond), then_block(then_block), else_block(else_block) {
    liong::assert(cond != nullptr);
    liong::assert(then_block != nullptr);
    liong::assert(else_block != nullptr);
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtConditionalBranch>()) { return false; }
    const auto& b2_ = b_->as<StmtConditionalBranch>();
    if (!cond->structured_eq(b2_.cond)) { return false; }
    if (!then_block->structured_eq(b2_.then_block)) { return false; }
    if (!else_block->structured_eq(b2_.else_block)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(cond);
    drain->push(then_block);
    drain->push(else_block);
  }
};

struct StmtLoop : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP;
  StmtRef body_block;
  StmtRef continue_block;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoop(
    const StmtRef& body_block,
    const StmtRef& continue_block,
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP), body_block(body_block), continue_block(continue_block), handle(handle) {
    liong::assert(body_block != nullptr);
    liong::assert(continue_block != nullptr);
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtLoop>()) { return false; }
    const auto& b2_ = b_->as<StmtLoop>();
    if (!body_block->structured_eq(b2_.body_block)) { return false; }
    if (!continue_block->structured_eq(b2_.continue_block)) { return false; }
    if (handle != b2_.handle) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(body_block);
    drain->push(continue_block);
  }
};

struct StmtConditionalLoop : public Stmt {
  static const StmtOp OP = L_STMT_OP_CONDITIONAL_LOOP;
  ExprRef cond;
  StmtRef body_block;
  StmtRef continue_block;
  std::shared_ptr<uint8_t> handle;

  inline StmtConditionalLoop(
    const ExprRef& cond,
    const StmtRef& body_block,
    const StmtRef& continue_block,
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_CONDITIONAL_LOOP), cond(cond), body_block(body_block), continue_block(continue_block), handle(handle) {
    liong::assert(cond != nullptr);
    liong::assert(body_block != nullptr);
    liong::assert(continue_block != nullptr);
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtConditionalLoop>()) { return false; }
    const auto& b2_ = b_->as<StmtConditionalLoop>();
    if (!cond->structured_eq(b2_.cond)) { return false; }
    if (!body_block->structured_eq(b2_.body_block)) { return false; }
    if (!continue_block->structured_eq(b2_.continue_block)) { return false; }
    if (handle != b2_.handle) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(cond);
    drain->push(body_block);
    drain->push(continue_block);
  }
};

struct StmtReturn : public Stmt {
  static const StmtOp OP = L_STMT_OP_RETURN;

  inline StmtReturn(
  ) : Stmt(L_STMT_OP_RETURN) {
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtReturn>()) { return false; }
    const auto& b2_ = b_->as<StmtReturn>();
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtLoopMerge : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_MERGE;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoopMerge(
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP_MERGE), handle(handle) {
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtLoopMerge>()) { return false; }
    const auto& b2_ = b_->as<StmtLoopMerge>();
    if (handle != b2_.handle) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtLoopContinue : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_CONTINUE;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoopContinue(
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP_CONTINUE), handle(handle) {
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtLoopContinue>()) { return false; }
    const auto& b2_ = b_->as<StmtLoopContinue>();
    if (handle != b2_.handle) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtLoopBackEdge : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_BACK_EDGE;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoopBackEdge(
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP_BACK_EDGE), handle(handle) {
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtLoopBackEdge>()) { return false; }
    const auto& b2_ = b_->as<StmtLoopBackEdge>();
    if (handle != b2_.handle) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtRangedLoop : public Stmt {
  static const StmtOp OP = L_STMT_OP_RANGED_LOOP;
  StmtRef body_block;
  MemoryRef itervar;

  inline StmtRangedLoop(
    const StmtRef& body_block,
    const MemoryRef& itervar
  ) : Stmt(L_STMT_OP_RANGED_LOOP), body_block(body_block), itervar(itervar) {
    liong::assert(body_block != nullptr);
    liong::assert(itervar != nullptr);
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtRangedLoop>()) { return false; }
    const auto& b2_ = b_->as<StmtRangedLoop>();
    if (!body_block->structured_eq(b2_.body_block)) { return false; }
    if (!itervar->structured_eq(b2_.itervar)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(body_block);
    drain->push(itervar);
  }
};

struct StmtStore : public Stmt {
  static const StmtOp OP = L_STMT_OP_STORE;
  MemoryRef dst_ptr;
  ExprRef value;

  inline StmtStore(
    const MemoryRef& dst_ptr,
    const ExprRef& value
  ) : Stmt(L_STMT_OP_STORE), dst_ptr(dst_ptr), value(value) {
    liong::assert(dst_ptr != nullptr);
    liong::assert(value != nullptr);
  }

  virtual bool structured_eq(StmtRef b_) const override final {
    if (!b_->is<StmtStore>()) { return false; }
    const auto& b2_ = b_->as<StmtStore>();
    if (!dst_ptr->structured_eq(b2_.dst_ptr)) { return false; }
    if (!value->structured_eq(b2_.value)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(dst_ptr);
    drain->push(value);
  }
};
