// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Stmt node implementation.
// @PENGUINLIONG
#pragma once
#include "node/reg.hpp"

struct StmtPatternCapture : public Stmt {
  static const StmtOp OP = L_STMT_OP_PATTERN_CAPTURE;
  NodeRef<Stmt> captured;

  inline StmtPatternCapture(
    const NodeRef<Stmt>& captured
  ) : Stmt(L_STMT_OP_PATTERN_CAPTURE), captured(captured) {
    liong::assert(captured != nullptr);
  }
  inline StmtPatternCapture() : Stmt(L_STMT_OP_PATTERN_CAPTURE) {}

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(captured);
  }
};

struct StmtPatternHead : public Stmt {
  static const StmtOp OP = L_STMT_OP_PATTERN_HEAD;
  NodeRef<Stmt> inner;

  inline StmtPatternHead(
    const NodeRef<Stmt>& inner
  ) : Stmt(L_STMT_OP_PATTERN_HEAD), inner(inner) {
    liong::assert(inner != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(inner);
  }
};

struct StmtPatternTail : public Stmt {
  static const StmtOp OP = L_STMT_OP_PATTERN_TAIL;
  NodeRef<Stmt> inner;

  inline StmtPatternTail(
    const NodeRef<Stmt>& inner
  ) : Stmt(L_STMT_OP_PATTERN_TAIL), inner(inner) {
    liong::assert(inner != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(inner);
  }
};

struct StmtNop : public Stmt {
  static const StmtOp OP = L_STMT_OP_NOP;

  inline StmtNop(
  ) : Stmt(L_STMT_OP_NOP) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtBlock : public Stmt {
  static const StmtOp OP = L_STMT_OP_BLOCK;
  std::vector<NodeRef<Stmt>> stmts;

  inline StmtBlock(
    const std::vector<NodeRef<Stmt>>& stmts
  ) : Stmt(L_STMT_OP_BLOCK), stmts(stmts) {
    for (const auto& x : stmts) { liong::assert(x != nullptr); }
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    for (const auto& x : stmts) { drain->push(x); }
  }
};

struct StmtConditionalBranch : public Stmt {
  static const StmtOp OP = L_STMT_OP_CONDITIONAL_BRANCH;
  NodeRef<Expr> cond;
  NodeRef<Stmt> then_block;
  NodeRef<Stmt> else_block;

  inline StmtConditionalBranch(
    const NodeRef<Expr>& cond,
    const NodeRef<Stmt>& then_block,
    const NodeRef<Stmt>& else_block
  ) : Stmt(L_STMT_OP_CONDITIONAL_BRANCH), cond(cond), then_block(then_block), else_block(else_block) {
    liong::assert(cond != nullptr);
    liong::assert(then_block != nullptr);
    liong::assert(else_block != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(cond);
    drain->push(then_block);
    drain->push(else_block);
  }
};

struct StmtLoop : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP;
  NodeRef<Stmt> body_block;
  NodeRef<Stmt> continue_block;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoop(
    const NodeRef<Stmt>& body_block,
    const NodeRef<Stmt>& continue_block,
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP), body_block(body_block), continue_block(continue_block), handle(handle) {
    liong::assert(body_block != nullptr);
    liong::assert(continue_block != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(body_block);
    drain->push(continue_block);
  }
};

struct StmtReturn : public Stmt {
  static const StmtOp OP = L_STMT_OP_RETURN;

  inline StmtReturn(
  ) : Stmt(L_STMT_OP_RETURN) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtLoopMerge : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_MERGE;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoopMerge(
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP_MERGE), handle(handle) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtLoopContinue : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_CONTINUE;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoopContinue(
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP_CONTINUE), handle(handle) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtLoopBackEdge : public Stmt {
  static const StmtOp OP = L_STMT_OP_LOOP_BACK_EDGE;
  std::shared_ptr<uint8_t> handle;

  inline StmtLoopBackEdge(
    std::shared_ptr<uint8_t> handle
  ) : Stmt(L_STMT_OP_LOOP_BACK_EDGE), handle(handle) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct StmtRangedLoop : public Stmt {
  static const StmtOp OP = L_STMT_OP_RANGED_LOOP;
  NodeRef<Stmt> body_block;
  NodeRef<Memory> itervar;

  inline StmtRangedLoop(
    const NodeRef<Stmt>& body_block,
    const NodeRef<Memory>& itervar
  ) : Stmt(L_STMT_OP_RANGED_LOOP), body_block(body_block), itervar(itervar) {
    liong::assert(body_block != nullptr);
    liong::assert(itervar != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(body_block);
    drain->push(itervar);
  }
};

struct StmtStore : public Stmt {
  static const StmtOp OP = L_STMT_OP_STORE;
  NodeRef<Memory> dst_ptr;
  NodeRef<Expr> value;

  inline StmtStore(
    const NodeRef<Memory>& dst_ptr,
    const NodeRef<Expr>& value
  ) : Stmt(L_STMT_OP_STORE), dst_ptr(dst_ptr), value(value) {
    liong::assert(dst_ptr != nullptr);
    liong::assert(value != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(dst_ptr);
    drain->push(value);
  }
};

typedef NodeRef<Stmt> StmtRef;
typedef NodeRef<StmtPatternCapture> StmtPatternCaptureRef;
typedef NodeRef<StmtPatternHead> StmtPatternHeadRef;
typedef NodeRef<StmtPatternTail> StmtPatternTailRef;
typedef NodeRef<StmtNop> StmtNopRef;
typedef NodeRef<StmtBlock> StmtBlockRef;
typedef NodeRef<StmtConditionalBranch> StmtConditionalBranchRef;
typedef NodeRef<StmtLoop> StmtLoopRef;
typedef NodeRef<StmtReturn> StmtReturnRef;
typedef NodeRef<StmtLoopMerge> StmtLoopMergeRef;
typedef NodeRef<StmtLoopContinue> StmtLoopContinueRef;
typedef NodeRef<StmtLoopBackEdge> StmtLoopBackEdgeRef;
typedef NodeRef<StmtRangedLoop> StmtRangedLoopRef;
typedef NodeRef<StmtStore> StmtStoreRef;
