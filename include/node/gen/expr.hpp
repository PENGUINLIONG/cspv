// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Expr node implementation.
// @PENGUINLIONG
#pragma once
#include "node/reg.hpp"

struct ExprConstant : public Expr {
  static const ExprOp OP = L_EXPR_OP_CONSTANT;
  std::vector<uint32_t> lits;

  inline ExprConstant(
    const NodeRef<Type>& ty,
    std::vector<uint32_t> lits
  ) : Expr(L_EXPR_OP_CONSTANT, ty), lits(lits) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct ExprLoad : public Expr {
  static const ExprOp OP = L_EXPR_OP_LOAD;
  NodeRef<Memory> src_ptr;

  inline ExprLoad(
    const NodeRef<Type>& ty,
    const NodeRef<Memory>& src_ptr
  ) : Expr(L_EXPR_OP_LOAD, ty), src_ptr(src_ptr) {
    liong::assert(src_ptr != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(src_ptr);
  }
};

struct ExprAdd : public Expr {
  static const ExprOp OP = L_EXPR_OP_ADD;
  NodeRef<Expr> a;
  NodeRef<Expr> b;

  inline ExprAdd(
    const NodeRef<Type>& ty,
    const NodeRef<Expr>& a,
    const NodeRef<Expr>& b
  ) : Expr(L_EXPR_OP_ADD, ty), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(a);
    drain->push(b);
  }
};

struct ExprSub : public Expr {
  static const ExprOp OP = L_EXPR_OP_SUB;
  NodeRef<Expr> a;
  NodeRef<Expr> b;

  inline ExprSub(
    const NodeRef<Type>& ty,
    const NodeRef<Expr>& a,
    const NodeRef<Expr>& b
  ) : Expr(L_EXPR_OP_SUB, ty), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(a);
    drain->push(b);
  }
};

struct ExprLt : public Expr {
  static const ExprOp OP = L_EXPR_OP_LT;
  NodeRef<Expr> a;
  NodeRef<Expr> b;

  inline ExprLt(
    const NodeRef<Type>& ty,
    const NodeRef<Expr>& a,
    const NodeRef<Expr>& b
  ) : Expr(L_EXPR_OP_LT, ty), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(a);
    drain->push(b);
  }
};

struct ExprEq : public Expr {
  static const ExprOp OP = L_EXPR_OP_EQ;
  NodeRef<Expr> a;
  NodeRef<Expr> b;

  inline ExprEq(
    const NodeRef<Type>& ty,
    const NodeRef<Expr>& a,
    const NodeRef<Expr>& b
  ) : Expr(L_EXPR_OP_EQ, ty), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(a);
    drain->push(b);
  }
};

struct ExprNot : public Expr {
  static const ExprOp OP = L_EXPR_OP_NOT;
  NodeRef<Expr> a;

  inline ExprNot(
    const NodeRef<Type>& ty,
    const NodeRef<Expr>& a
  ) : Expr(L_EXPR_OP_NOT, ty), a(a) {
    liong::assert(a != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(a);
  }
};

struct ExprTypeCast : public Expr {
  static const ExprOp OP = L_EXPR_OP_TYPE_CAST;
  NodeRef<Expr> src;

  inline ExprTypeCast(
    const NodeRef<Type>& ty,
    const NodeRef<Expr>& src
  ) : Expr(L_EXPR_OP_TYPE_CAST, ty), src(src) {
    liong::assert(src != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(src);
  }
};

struct ExprSelect : public Expr {
  static const ExprOp OP = L_EXPR_OP_SELECT;
  NodeRef<Expr> cond;
  NodeRef<Expr> a;
  NodeRef<Expr> b;

  inline ExprSelect(
    const NodeRef<Type>& ty,
    const NodeRef<Expr>& cond,
    const NodeRef<Expr>& a,
    const NodeRef<Expr>& b
  ) : Expr(L_EXPR_OP_SELECT, ty), cond(cond), a(a), b(b) {
    liong::assert(cond != nullptr);
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(cond);
    drain->push(a);
    drain->push(b);
  }
};

typedef NodeRef<Expr> ExprRef;
typedef NodeRef<ExprConstant> ExprConstantRef;
typedef NodeRef<ExprLoad> ExprLoadRef;
typedef NodeRef<ExprAdd> ExprAddRef;
typedef NodeRef<ExprSub> ExprSubRef;
typedef NodeRef<ExprLt> ExprLtRef;
typedef NodeRef<ExprEq> ExprEqRef;
typedef NodeRef<ExprNot> ExprNotRef;
typedef NodeRef<ExprTypeCast> ExprTypeCastRef;
typedef NodeRef<ExprSelect> ExprSelectRef;
