// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Expr node implementation.
// @PENGUINLIONG
#pragma once
#include "node/reg.hpp"

typedef Reference<struct ExprPatternCapture> ExprPatternCaptureRef;
typedef Reference<struct ExprPatternBinaryOp> ExprPatternBinaryOpRef;
typedef Reference<struct ExprBoolImm> ExprBoolImmRef;
typedef Reference<struct ExprIntImm> ExprIntImmRef;
typedef Reference<struct ExprFloatImm> ExprFloatImmRef;
typedef Reference<struct ExprLoad> ExprLoadRef;
typedef Reference<struct ExprAdd> ExprAddRef;
typedef Reference<struct ExprSub> ExprSubRef;
typedef Reference<struct ExprMul> ExprMulRef;
typedef Reference<struct ExprDiv> ExprDivRef;
typedef Reference<struct ExprMod> ExprModRef;
typedef Reference<struct ExprLt> ExprLtRef;
typedef Reference<struct ExprEq> ExprEqRef;
typedef Reference<struct ExprNot> ExprNotRef;
typedef Reference<struct ExprTypeCast> ExprTypeCastRef;
typedef Reference<struct ExprSelect> ExprSelectRef;

struct ExprPatternCapture : public Expr {
  static const ExprOp OP = L_EXPR_OP_PATTERN_CAPTURE;
  ExprRef captured;

  inline ExprPatternCapture(
    const TypeRef& ty,
    const ExprRef& captured
  ) : Expr(L_EXPR_OP_PATTERN_CAPTURE, ty), captured(captured) {
    liong::assert(captured != nullptr);
  }
  inline ExprPatternCapture(const TypeRef& ty) : Expr(L_EXPR_OP_PATTERN_CAPTURE, ty) {}

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprPatternCapture>()) { return false; }
    const auto& b2_ = b_->as<ExprPatternCapture>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!captured->structured_eq(b2_.captured)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(captured);
  }
};

struct ExprPatternBinaryOp : public Expr {
  static const ExprOp OP = L_EXPR_OP_PATTERN_BINARY_OP;
  std::shared_ptr<ExprOp> op;
  ExprRef a;
  ExprRef b;

  inline ExprPatternBinaryOp(
    const TypeRef& ty,
    std::shared_ptr<ExprOp> op,
    const ExprRef& a,
    const ExprRef& b
  ) : Expr(L_EXPR_OP_PATTERN_BINARY_OP, ty), op(op), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }
  inline ExprPatternBinaryOp(const TypeRef& ty) : Expr(L_EXPR_OP_PATTERN_BINARY_OP, ty) {}

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprPatternBinaryOp>()) { return false; }
    const auto& b2_ = b_->as<ExprPatternBinaryOp>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (op != b2_.op) { return false; }
    if (!a->structured_eq(b2_.a)) { return false; }
    if (!b->structured_eq(b2_.b)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(a);
    drain->push(b);
  }
};

struct ExprBoolImm : public Expr {
  static const ExprOp OP = L_EXPR_OP_BOOL_IMM;
  bool lit;

  inline ExprBoolImm(
    const TypeRef& ty,
    bool lit
  ) : Expr(L_EXPR_OP_BOOL_IMM, ty), lit(lit) {
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprBoolImm>()) { return false; }
    const auto& b2_ = b_->as<ExprBoolImm>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (lit != b2_.lit) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
  }
};

struct ExprIntImm : public Expr {
  static const ExprOp OP = L_EXPR_OP_INT_IMM;
  int64_t lit;

  inline ExprIntImm(
    const TypeRef& ty,
    int64_t lit
  ) : Expr(L_EXPR_OP_INT_IMM, ty), lit(lit) {
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprIntImm>()) { return false; }
    const auto& b2_ = b_->as<ExprIntImm>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (lit != b2_.lit) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
  }
};

struct ExprFloatImm : public Expr {
  static const ExprOp OP = L_EXPR_OP_FLOAT_IMM;
  double lit;

  inline ExprFloatImm(
    const TypeRef& ty,
    double lit
  ) : Expr(L_EXPR_OP_FLOAT_IMM, ty), lit(lit) {
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprFloatImm>()) { return false; }
    const auto& b2_ = b_->as<ExprFloatImm>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (lit != b2_.lit) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
  }
};

struct ExprLoad : public Expr {
  static const ExprOp OP = L_EXPR_OP_LOAD;
  MemoryRef src_ptr;

  inline ExprLoad(
    const TypeRef& ty,
    const MemoryRef& src_ptr
  ) : Expr(L_EXPR_OP_LOAD, ty), src_ptr(src_ptr) {
    liong::assert(src_ptr != nullptr);
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprLoad>()) { return false; }
    const auto& b2_ = b_->as<ExprLoad>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!src_ptr->structured_eq(b2_.src_ptr)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(src_ptr);
  }
};

struct ExprAdd : public Expr {
  static const ExprOp OP = L_EXPR_OP_ADD;
  ExprRef a;
  ExprRef b;

  inline ExprAdd(
    const TypeRef& ty,
    const ExprRef& a,
    const ExprRef& b
  ) : Expr(L_EXPR_OP_ADD, ty), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprAdd>()) { return false; }
    const auto& b2_ = b_->as<ExprAdd>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!a->structured_eq(b2_.a)) { return false; }
    if (!b->structured_eq(b2_.b)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(a);
    drain->push(b);
  }
};

struct ExprSub : public Expr {
  static const ExprOp OP = L_EXPR_OP_SUB;
  ExprRef a;
  ExprRef b;

  inline ExprSub(
    const TypeRef& ty,
    const ExprRef& a,
    const ExprRef& b
  ) : Expr(L_EXPR_OP_SUB, ty), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprSub>()) { return false; }
    const auto& b2_ = b_->as<ExprSub>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!a->structured_eq(b2_.a)) { return false; }
    if (!b->structured_eq(b2_.b)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(a);
    drain->push(b);
  }
};

struct ExprMul : public Expr {
  static const ExprOp OP = L_EXPR_OP_MUL;
  ExprRef a;
  ExprRef b;

  inline ExprMul(
    const TypeRef& ty,
    const ExprRef& a,
    const ExprRef& b
  ) : Expr(L_EXPR_OP_MUL, ty), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprMul>()) { return false; }
    const auto& b2_ = b_->as<ExprMul>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!a->structured_eq(b2_.a)) { return false; }
    if (!b->structured_eq(b2_.b)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(a);
    drain->push(b);
  }
};

struct ExprDiv : public Expr {
  static const ExprOp OP = L_EXPR_OP_DIV;
  ExprRef a;
  ExprRef b;

  inline ExprDiv(
    const TypeRef& ty,
    const ExprRef& a,
    const ExprRef& b
  ) : Expr(L_EXPR_OP_DIV, ty), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprDiv>()) { return false; }
    const auto& b2_ = b_->as<ExprDiv>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!a->structured_eq(b2_.a)) { return false; }
    if (!b->structured_eq(b2_.b)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(a);
    drain->push(b);
  }
};

struct ExprMod : public Expr {
  static const ExprOp OP = L_EXPR_OP_MOD;
  ExprRef a;
  ExprRef b;

  inline ExprMod(
    const TypeRef& ty,
    const ExprRef& a,
    const ExprRef& b
  ) : Expr(L_EXPR_OP_MOD, ty), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprMod>()) { return false; }
    const auto& b2_ = b_->as<ExprMod>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!a->structured_eq(b2_.a)) { return false; }
    if (!b->structured_eq(b2_.b)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(a);
    drain->push(b);
  }
};

struct ExprLt : public Expr {
  static const ExprOp OP = L_EXPR_OP_LT;
  ExprRef a;
  ExprRef b;

  inline ExprLt(
    const TypeRef& ty,
    const ExprRef& a,
    const ExprRef& b
  ) : Expr(L_EXPR_OP_LT, ty), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprLt>()) { return false; }
    const auto& b2_ = b_->as<ExprLt>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!a->structured_eq(b2_.a)) { return false; }
    if (!b->structured_eq(b2_.b)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(a);
    drain->push(b);
  }
};

struct ExprEq : public Expr {
  static const ExprOp OP = L_EXPR_OP_EQ;
  ExprRef a;
  ExprRef b;

  inline ExprEq(
    const TypeRef& ty,
    const ExprRef& a,
    const ExprRef& b
  ) : Expr(L_EXPR_OP_EQ, ty), a(a), b(b) {
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprEq>()) { return false; }
    const auto& b2_ = b_->as<ExprEq>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!a->structured_eq(b2_.a)) { return false; }
    if (!b->structured_eq(b2_.b)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(a);
    drain->push(b);
  }
};

struct ExprNot : public Expr {
  static const ExprOp OP = L_EXPR_OP_NOT;
  ExprRef a;

  inline ExprNot(
    const TypeRef& ty,
    const ExprRef& a
  ) : Expr(L_EXPR_OP_NOT, ty), a(a) {
    liong::assert(a != nullptr);
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprNot>()) { return false; }
    const auto& b2_ = b_->as<ExprNot>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!a->structured_eq(b2_.a)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(a);
  }
};

struct ExprTypeCast : public Expr {
  static const ExprOp OP = L_EXPR_OP_TYPE_CAST;
  ExprRef src;

  inline ExprTypeCast(
    const TypeRef& ty,
    const ExprRef& src
  ) : Expr(L_EXPR_OP_TYPE_CAST, ty), src(src) {
    liong::assert(src != nullptr);
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprTypeCast>()) { return false; }
    const auto& b2_ = b_->as<ExprTypeCast>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!src->structured_eq(b2_.src)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(src);
  }
};

struct ExprSelect : public Expr {
  static const ExprOp OP = L_EXPR_OP_SELECT;
  ExprRef cond;
  ExprRef a;
  ExprRef b;

  inline ExprSelect(
    const TypeRef& ty,
    const ExprRef& cond,
    const ExprRef& a,
    const ExprRef& b
  ) : Expr(L_EXPR_OP_SELECT, ty), cond(cond), a(a), b(b) {
    liong::assert(cond != nullptr);
    liong::assert(a != nullptr);
    liong::assert(b != nullptr);
  }

  virtual bool structured_eq(ExprRef b_) const override final {
    if (!b_->is<ExprSelect>()) { return false; }
    const auto& b2_ = b_->as<ExprSelect>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (!cond->structured_eq(b2_.cond)) { return false; }
    if (!a->structured_eq(b2_.a)) { return false; }
    if (!b->structured_eq(b2_.b)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    drain->push(cond);
    drain->push(a);
    drain->push(b);
  }
};

constexpr bool is_expr_binary_op(ExprOp op) {
  switch (op) {
  case L_EXPR_OP_LT:
  case L_EXPR_OP_SUB:
  case L_EXPR_OP_MOD:
  case L_EXPR_OP_ADD:
  case L_EXPR_OP_DIV:
  case L_EXPR_OP_EQ:
  case L_EXPR_OP_MUL:
    return true;
  default: return false;
  }
}
constexpr bool is_expr_constant(ExprOp op) {
  switch (op) {
  case L_EXPR_OP_BOOL_IMM:
  case L_EXPR_OP_INT_IMM:
  case L_EXPR_OP_FLOAT_IMM:
    return true;
  default: return false;
  }
}
constexpr bool is_expr_unary_op(ExprOp op) {
  switch (op) {
  case L_EXPR_OP_NOT:
  case L_EXPR_OP_TYPE_CAST:
    return true;
  default: return false;
  }
}