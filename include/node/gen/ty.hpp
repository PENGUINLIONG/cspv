// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Type node implementation.
// @PENGUINLIONG
#pragma once
#include "node/reg.hpp"

struct TypePatternCapture : public Type {
  static const TypeClass CLS = L_TYPE_CLASS_PATTERN_CAPTURE;
  NodeRef<Type> captured;

  inline TypePatternCapture(
    const NodeRef<Type>& captured
  ) : Type(L_TYPE_CLASS_PATTERN_CAPTURE), captured(captured) {
    liong::assert(captured != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(captured);
  }
};

struct TypeVoid : public Type {
  static const TypeClass CLS = L_TYPE_CLASS_VOID;

  inline TypeVoid(
  ) : Type(L_TYPE_CLASS_VOID) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct TypeBool : public Type {
  static const TypeClass CLS = L_TYPE_CLASS_BOOL;

  inline TypeBool(
  ) : Type(L_TYPE_CLASS_BOOL) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct TypeInt : public Type {
  static const TypeClass CLS = L_TYPE_CLASS_INT;
  uint32_t nbit;
  bool is_signed;

  inline TypeInt(
    uint32_t nbit,
    bool is_signed
  ) : Type(L_TYPE_CLASS_INT), nbit(nbit), is_signed(is_signed) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct TypeFloat : public Type {
  static const TypeClass CLS = L_TYPE_CLASS_FLOAT;
  uint32_t nbit;

  inline TypeFloat(
    uint32_t nbit
  ) : Type(L_TYPE_CLASS_FLOAT), nbit(nbit) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
  }
};

struct TypeStruct : public Type {
  static const TypeClass CLS = L_TYPE_CLASS_STRUCT;
  std::vector<NodeRef<Type>> members;

  inline TypeStruct(
    const std::vector<NodeRef<Type>>& members
  ) : Type(L_TYPE_CLASS_STRUCT), members(members) {
    for (const auto& x : members) { liong::assert(x != nullptr); }
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    for (const auto& x : members) { drain->push(x); }
  }
};

struct TypePointer : public Type {
  static const TypeClass CLS = L_TYPE_CLASS_POINTER;
  NodeRef<Type> inner;

  inline TypePointer(
    const NodeRef<Type>& inner
  ) : Type(L_TYPE_CLASS_POINTER), inner(inner) {
    liong::assert(inner != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(inner);
  }
};

typedef NodeRef<Type> TypeRef;
typedef NodeRef<TypePatternCapture> TypePatternCaptureRef;
typedef NodeRef<TypeVoid> TypeVoidRef;
typedef NodeRef<TypeBool> TypeBoolRef;
typedef NodeRef<TypeInt> TypeIntRef;
typedef NodeRef<TypeFloat> TypeFloatRef;
typedef NodeRef<TypeStruct> TypeStructRef;
typedef NodeRef<TypePointer> TypePointerRef;
