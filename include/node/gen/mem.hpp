// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Memory node implementation.
// @PENGUINLIONG
#pragma once
#include "node/reg.hpp"

typedef Reference<struct MemoryPatternCapture> MemoryPatternCaptureRef;
typedef Reference<struct MemoryFunctionVariable> MemoryFunctionVariableRef;
typedef Reference<struct MemoryIterationVariable> MemoryIterationVariableRef;
typedef Reference<struct MemoryUniformBuffer> MemoryUniformBufferRef;
typedef Reference<struct MemoryStorageBuffer> MemoryStorageBufferRef;
typedef Reference<struct MemorySampledImage> MemorySampledImageRef;
typedef Reference<struct MemoryStorageImage> MemoryStorageImageRef;

struct MemoryPatternCapture : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_PATTERN_CAPTURE;
  MemoryRef captured;

  inline MemoryPatternCapture(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    const MemoryRef& captured
  ) : Memory(L_MEMORY_CLASS_PATTERN_CAPTURE, ty, ac), captured(captured) {
    liong::assert(captured != nullptr);
  }
  inline MemoryPatternCapture(const TypeRef& ty, const std::vector<ExprRef>& ac) : Memory(L_MEMORY_CLASS_PATTERN_CAPTURE, ty, ac) {}

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
    drain->push(captured);
  }
};

struct MemoryFunctionVariable : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_FUNCTION_VARIABLE;
  std::shared_ptr<uint8_t> handle;

  inline MemoryFunctionVariable(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    std::shared_ptr<uint8_t> handle
  ) : Memory(L_MEMORY_CLASS_FUNCTION_VARIABLE, ty, ac), handle(handle) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemoryIterationVariable : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_ITERATION_VARIABLE;
  ExprRef begin;
  ExprRef end;
  ExprRef stride;

  inline MemoryIterationVariable(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    const ExprRef& begin,
    const ExprRef& end,
    const ExprRef& stride
  ) : Memory(L_MEMORY_CLASS_ITERATION_VARIABLE, ty, ac), begin(begin), end(end), stride(stride) {
    liong::assert(begin != nullptr);
    liong::assert(end != nullptr);
    liong::assert(stride != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
    drain->push(begin);
    drain->push(end);
    drain->push(stride);
  }
};

struct MemoryUniformBuffer : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_UNIFORM_BUFFER;
  uint32_t binding;
  uint32_t set;

  inline MemoryUniformBuffer(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_UNIFORM_BUFFER, ty, ac), binding(binding), set(set) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemoryStorageBuffer : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_STORAGE_BUFFER;
  uint32_t binding;
  uint32_t set;

  inline MemoryStorageBuffer(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_STORAGE_BUFFER, ty, ac), binding(binding), set(set) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemorySampledImage : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_SAMPLED_IMAGE;
  uint32_t binding;
  uint32_t set;

  inline MemorySampledImage(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_SAMPLED_IMAGE, ty, ac), binding(binding), set(set) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemoryStorageImage : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_STORAGE_IMAGE;
  uint32_t binding;
  uint32_t set;

  inline MemoryStorageImage(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_STORAGE_IMAGE, ty, ac), binding(binding), set(set) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};
