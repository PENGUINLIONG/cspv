// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Memory node implementation.
// @PENGUINLIONG
#pragma once
#include "node/reg.hpp"

typedef Reference<struct MemoryPatternCapture> MemoryPatternCaptureRef;
typedef Reference<struct MemoryFunctionVariable> MemoryFunctionVariableRef;
typedef Reference<struct MemoryIterationVariable> MemoryIterationVariableRef;
typedef Reference<struct MemoryUniformBuffer> MemoryUniformBufferRef;
typedef Reference<struct MemoryStorageBuffer> MemoryStorageBufferRef;
typedef Reference<struct MemorySampledImage> MemorySampledImageRef;
typedef Reference<struct MemoryStorageImage> MemoryStorageImageRef;

struct MemoryPatternCapture : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_PATTERN_CAPTURE;
  MemoryRef captured;

  inline MemoryPatternCapture(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    const MemoryRef& captured
  ) : Memory(L_MEMORY_CLASS_PATTERN_CAPTURE, ty, ac), captured(captured) {
    liong::assert(captured != nullptr);
  }
  inline MemoryPatternCapture(const TypeRef& ty, const std::vector<ExprRef>& ac) : Memory(L_MEMORY_CLASS_PATTERN_CAPTURE, ty, ac) {}

  virtual bool structured_eq(MemoryRef b_) const override final {
    if (!b_->is<MemoryPatternCapture>()) { return false; }
    const auto& b2_ = b_->as<MemoryPatternCapture>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (ac.size() != b2_.ac.size()) { return false; }
    for (size_t i = 0; i < ac.size(); ++i) {
      if (!ac.at(i)->structured_eq(b2_.ac.at(i))) { return false; }
    }
    if (!captured->structured_eq(b2_.captured)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
    drain->push(captured);
  }
};

struct MemoryFunctionVariable : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_FUNCTION_VARIABLE;
  std::shared_ptr<uint8_t> handle;

  inline MemoryFunctionVariable(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    std::shared_ptr<uint8_t> handle
  ) : Memory(L_MEMORY_CLASS_FUNCTION_VARIABLE, ty, ac), handle(handle) {
  }

  virtual bool structured_eq(MemoryRef b_) const override final {
    if (!b_->is<MemoryFunctionVariable>()) { return false; }
    const auto& b2_ = b_->as<MemoryFunctionVariable>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (ac.size() != b2_.ac.size()) { return false; }
    for (size_t i = 0; i < ac.size(); ++i) {
      if (!ac.at(i)->structured_eq(b2_.ac.at(i))) { return false; }
    }
    if (handle != b2_.handle) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemoryIterationVariable : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_ITERATION_VARIABLE;
  ExprRef begin;
  ExprRef end;
  ExprRef stride;

  inline MemoryIterationVariable(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    const ExprRef& begin,
    const ExprRef& end,
    const ExprRef& stride
  ) : Memory(L_MEMORY_CLASS_ITERATION_VARIABLE, ty, ac), begin(begin), end(end), stride(stride) {
    liong::assert(begin != nullptr);
    liong::assert(end != nullptr);
    liong::assert(stride != nullptr);
  }

  virtual bool structured_eq(MemoryRef b_) const override final {
    if (!b_->is<MemoryIterationVariable>()) { return false; }
    const auto& b2_ = b_->as<MemoryIterationVariable>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (ac.size() != b2_.ac.size()) { return false; }
    for (size_t i = 0; i < ac.size(); ++i) {
      if (!ac.at(i)->structured_eq(b2_.ac.at(i))) { return false; }
    }
    if (!begin->structured_eq(b2_.begin)) { return false; }
    if (!end->structured_eq(b2_.end)) { return false; }
    if (!stride->structured_eq(b2_.stride)) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
    drain->push(begin);
    drain->push(end);
    drain->push(stride);
  }
};

struct MemoryUniformBuffer : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_UNIFORM_BUFFER;
  uint32_t binding;
  uint32_t set;

  inline MemoryUniformBuffer(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_UNIFORM_BUFFER, ty, ac), binding(binding), set(set) {
  }

  virtual bool structured_eq(MemoryRef b_) const override final {
    if (!b_->is<MemoryUniformBuffer>()) { return false; }
    const auto& b2_ = b_->as<MemoryUniformBuffer>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (ac.size() != b2_.ac.size()) { return false; }
    for (size_t i = 0; i < ac.size(); ++i) {
      if (!ac.at(i)->structured_eq(b2_.ac.at(i))) { return false; }
    }
    if (binding != b2_.binding) { return false; }
    if (set != b2_.set) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemoryStorageBuffer : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_STORAGE_BUFFER;
  uint32_t binding;
  uint32_t set;

  inline MemoryStorageBuffer(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_STORAGE_BUFFER, ty, ac), binding(binding), set(set) {
  }

  virtual bool structured_eq(MemoryRef b_) const override final {
    if (!b_->is<MemoryStorageBuffer>()) { return false; }
    const auto& b2_ = b_->as<MemoryStorageBuffer>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (ac.size() != b2_.ac.size()) { return false; }
    for (size_t i = 0; i < ac.size(); ++i) {
      if (!ac.at(i)->structured_eq(b2_.ac.at(i))) { return false; }
    }
    if (binding != b2_.binding) { return false; }
    if (set != b2_.set) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemorySampledImage : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_SAMPLED_IMAGE;
  uint32_t binding;
  uint32_t set;

  inline MemorySampledImage(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_SAMPLED_IMAGE, ty, ac), binding(binding), set(set) {
  }

  virtual bool structured_eq(MemoryRef b_) const override final {
    if (!b_->is<MemorySampledImage>()) { return false; }
    const auto& b2_ = b_->as<MemorySampledImage>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (ac.size() != b2_.ac.size()) { return false; }
    for (size_t i = 0; i < ac.size(); ++i) {
      if (!ac.at(i)->structured_eq(b2_.ac.at(i))) { return false; }
    }
    if (binding != b2_.binding) { return false; }
    if (set != b2_.set) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemoryStorageImage : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_STORAGE_IMAGE;
  uint32_t binding;
  uint32_t set;

  inline MemoryStorageImage(
    const TypeRef& ty,
    const std::vector<ExprRef>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_STORAGE_IMAGE, ty, ac), binding(binding), set(set) {
  }

  virtual bool structured_eq(MemoryRef b_) const override final {
    if (!b_->is<MemoryStorageImage>()) { return false; }
    const auto& b2_ = b_->as<MemoryStorageImage>();
    if (!ty->structured_eq(b2_.ty)) { return false; }
    if (ac.size() != b2_.ac.size()) { return false; }
    for (size_t i = 0; i < ac.size(); ++i) {
      if (!ac.at(i)->structured_eq(b2_.ac.at(i))) { return false; }
    }
    if (binding != b2_.binding) { return false; }
    if (set != b2_.set) { return false; }
    return true;
  }
  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};
