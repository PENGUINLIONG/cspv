// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Memory node implementation.
// @PENGUINLIONG
#pragma once
#include "node/reg.hpp"

struct MemoryPatternCapture : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_PATTERN_CAPTURE;
  NodeRef<Memory> captured;

  inline MemoryPatternCapture(
    const NodeRef<Type>& ty,
    const std::vector<NodeRef<Expr>>& ac,
    const NodeRef<Memory>& captured
  ) : Memory(L_MEMORY_CLASS_PATTERN_CAPTURE, ty, ac), captured(captured) {
    liong::assert(captured != nullptr);
  }
  inline MemoryPatternCapture(const NodeRef<Type>& ty, const std::vector<NodeRef<Expr>>& ac) : Memory(L_MEMORY_CLASS_PATTERN_CAPTURE, ty, ac) {}

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
    drain->push(captured);
  }
};

struct MemoryFunctionVariable : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_FUNCTION_VARIABLE;
  std::shared_ptr<uint8_t> handle;

  inline MemoryFunctionVariable(
    const NodeRef<Type>& ty,
    const std::vector<NodeRef<Expr>>& ac,
    std::shared_ptr<uint8_t> handle
  ) : Memory(L_MEMORY_CLASS_FUNCTION_VARIABLE, ty, ac), handle(handle) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemoryIterationVariable : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_ITERATION_VARIABLE;
  NodeRef<Expr> begin;
  NodeRef<Expr> end;
  NodeRef<Expr> stride;

  inline MemoryIterationVariable(
    const NodeRef<Type>& ty,
    const std::vector<NodeRef<Expr>>& ac,
    const NodeRef<Expr>& begin,
    const NodeRef<Expr>& end,
    const NodeRef<Expr>& stride
  ) : Memory(L_MEMORY_CLASS_ITERATION_VARIABLE, ty, ac), begin(begin), end(end), stride(stride) {
    liong::assert(begin != nullptr);
    liong::assert(end != nullptr);
    liong::assert(stride != nullptr);
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
    drain->push(begin);
    drain->push(end);
    drain->push(stride);
  }
};

struct MemoryUniformBuffer : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_UNIFORM_BUFFER;
  uint32_t binding;
  uint32_t set;

  inline MemoryUniformBuffer(
    const NodeRef<Type>& ty,
    const std::vector<NodeRef<Expr>>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_UNIFORM_BUFFER, ty, ac), binding(binding), set(set) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemoryStorageBuffer : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_STORAGE_BUFFER;
  uint32_t binding;
  uint32_t set;

  inline MemoryStorageBuffer(
    const NodeRef<Type>& ty,
    const std::vector<NodeRef<Expr>>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_STORAGE_BUFFER, ty, ac), binding(binding), set(set) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemorySampledImage : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_SAMPLED_IMAGE;
  uint32_t binding;
  uint32_t set;

  inline MemorySampledImage(
    const NodeRef<Type>& ty,
    const std::vector<NodeRef<Expr>>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_SAMPLED_IMAGE, ty, ac), binding(binding), set(set) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

struct MemoryStorageImage : public Memory {
  static const MemoryClass CLS = L_MEMORY_CLASS_STORAGE_IMAGE;
  uint32_t binding;
  uint32_t set;

  inline MemoryStorageImage(
    const NodeRef<Type>& ty,
    const std::vector<NodeRef<Expr>>& ac,
    uint32_t binding,
    uint32_t set
  ) : Memory(L_MEMORY_CLASS_STORAGE_IMAGE, ty, ac), binding(binding), set(set) {
  }

  virtual void collect_children(NodeDrain* drain) const override final {
    drain->push(ty);
    for (const auto& x : ac) { drain->push(x); }
  }
};

typedef NodeRef<Memory> MemoryRef;
typedef NodeRef<MemoryPatternCapture> MemoryPatternCaptureRef;
typedef NodeRef<MemoryFunctionVariable> MemoryFunctionVariableRef;
typedef NodeRef<MemoryIterationVariable> MemoryIterationVariableRef;
typedef NodeRef<MemoryUniformBuffer> MemoryUniformBufferRef;
typedef NodeRef<MemoryStorageBuffer> MemoryStorageBufferRef;
typedef NodeRef<MemorySampledImage> MemorySampledImageRef;
typedef NodeRef<MemoryStorageImage> MemoryStorageImageRef;
