// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Expression node visitor.
// @PENGUINLIONG
#pragma once
#include "node/gen/expr.hpp"

typedef std::shared_ptr<Expr> ExprRef;
typedef std::shared_ptr<ExprConstant> ExprConstantRef;
typedef std::shared_ptr<ExprLoad> ExprLoadRef;
typedef std::shared_ptr<ExprAdd> ExprAddRef;
typedef std::shared_ptr<ExprSub> ExprSubRef;
typedef std::shared_ptr<ExprLt> ExprLtRef;
typedef std::shared_ptr<ExprEq> ExprEqRef;
typedef std::shared_ptr<ExprTypeCast> ExprTypeCastRef;

struct ExprVisitor {
  virtual void visit_expr(const Expr& expr) {
    switch (expr.op) {
    case L_EXPR_OP_CONSTANT: visit_expr_(*(const ExprConstant*)&expr); break;
    case L_EXPR_OP_LOAD: visit_expr_(*(const ExprLoad*)&expr); break;
    case L_EXPR_OP_ADD: visit_expr_(*(const ExprAdd*)&expr); break;
    case L_EXPR_OP_SUB: visit_expr_(*(const ExprSub*)&expr); break;
    case L_EXPR_OP_LT: visit_expr_(*(const ExprLt*)&expr); break;
    case L_EXPR_OP_EQ: visit_expr_(*(const ExprEq*)&expr); break;
    case L_EXPR_OP_TYPE_CAST: visit_expr_(*(const ExprTypeCast*)&expr); break;
    default: liong::unreachable();
    }
  }
  virtual void visit_expr_(const ExprConstant&);
  virtual void visit_expr_(const ExprLoad&);
  virtual void visit_expr_(const ExprAdd&);
  virtual void visit_expr_(const ExprSub&);
  virtual void visit_expr_(const ExprLt&);
  virtual void visit_expr_(const ExprEq&);
  virtual void visit_expr_(const ExprTypeCast&);
};

template<typename TExpr>
struct ExprFunctorVisitor : public ExprVisitor {
  std::function<void(const TExpr&)> f;
  ExprFunctorVisitor(std::function<void(const TExpr&)>&& f) :
    f(std::forward<std::function<void(const TExpr&)>>(f)) {}

  virtual void visit_expr_(const TExpr& expr) override final {
    f(expr);
  }
};
template<typename TExpr>
void visit_expr_functor(
  std::function<void(const TExpr&)>&& f,
  const Expr& x
) {
  ExprFunctorVisitor<TExpr> visitor(
    std::forward<std::function<void(const TExpr&)>>(f));
  visitor.visit_expr(x);
}

struct ExprMutator {
  virtual ExprRef mutate_expr(ExprRef& expr) {
    switch (expr->op) {
    case L_EXPR_OP_CONSTANT: return mutate_expr_(std::static_pointer_cast<ExprConstant>(expr));
    case L_EXPR_OP_LOAD: return mutate_expr_(std::static_pointer_cast<ExprLoad>(expr));
    case L_EXPR_OP_ADD: return mutate_expr_(std::static_pointer_cast<ExprAdd>(expr));
    case L_EXPR_OP_SUB: return mutate_expr_(std::static_pointer_cast<ExprSub>(expr));
    case L_EXPR_OP_LT: return mutate_expr_(std::static_pointer_cast<ExprLt>(expr));
    case L_EXPR_OP_EQ: return mutate_expr_(std::static_pointer_cast<ExprEq>(expr));
    case L_EXPR_OP_TYPE_CAST: return mutate_expr_(std::static_pointer_cast<ExprTypeCast>(expr));
    default: liong::unreachable();
    }
  }
  virtual ExprRef mutate_expr_(std::shared_ptr<ExprConstant>&);
  virtual ExprRef mutate_expr_(std::shared_ptr<ExprLoad>&);
  virtual ExprRef mutate_expr_(std::shared_ptr<ExprAdd>&);
  virtual ExprRef mutate_expr_(std::shared_ptr<ExprSub>&);
  virtual ExprRef mutate_expr_(std::shared_ptr<ExprLt>&);
  virtual ExprRef mutate_expr_(std::shared_ptr<ExprEq>&);
  virtual ExprRef mutate_expr_(std::shared_ptr<ExprTypeCast>&);
};

template<typename TExpr>
struct ExprFunctorMutator : public ExprMutator {
  typedef std::shared_ptr<TExpr> TStmtRef;
  std::function<ExprRef(TStmtRef&)> f;
  ExprFunctorMutator(std::function<ExprRef(TStmtRef&)>&& f) :
    f(std::forward<std::function<ExprRef(TStmtRef&)>>(f)) {}

  virtual ExprRef mutate_expr_(TStmtRef& expr) override final {
    return f(expr);
  }
};
template<typename TExpr>
void mutate_expr_functor(
  std::function<ExprRef(std::shared_ptr<TExpr>&)>&& f,
  const Expr& x
) {
  ExprFunctorMutator<TExpr> mutator(
    std::forward<std::function<ExprRef(std::shared_ptr<TExpr>&)>>(f));
  return mutator.mutate_expr(x);
}
