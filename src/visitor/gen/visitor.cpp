// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.
// Node visitor implementation.
// @PENGUINLIONG
#pragma once
#include "visitor/gen/visitor.hpp"

void Visitor::visit_mem_(const MemoryFunctionVariableRef& x) {
}
void Visitor::visit_mem_(const MemoryIterationVariableRef& x) {
}
void Visitor::visit_mem_(const MemoryUniformBufferRef& x) {
}
void Visitor::visit_mem_(const MemoryStorageBufferRef& x) {
}
void Visitor::visit_mem_(const MemorySampledImageRef& x) {
}
void Visitor::visit_mem_(const MemoryStorageImageRef& x) {
}

void Visitor::visit_ty_(const TypeVoidRef& x) {
}
void Visitor::visit_ty_(const TypeBoolRef& x) {
}
void Visitor::visit_ty_(const TypeIntRef& x) {
}
void Visitor::visit_ty_(const TypeFloatRef& x) {
}
void Visitor::visit_ty_(const TypeStructRef& x) {
  for (const auto& x : x->members) { visit_ty(x); }
}
void Visitor::visit_ty_(const TypePointerRef& x) {
  visit_ty(x->inner);
}

void Visitor::visit_expr_(const ExprConstantRef& x) {
}
void Visitor::visit_expr_(const ExprLoadRef& x) {
}
void Visitor::visit_expr_(const ExprAddRef& x) {
  visit_expr(x->a);
  visit_expr(x->b);
}
void Visitor::visit_expr_(const ExprSubRef& x) {
  visit_expr(x->a);
  visit_expr(x->b);
}
void Visitor::visit_expr_(const ExprLtRef& x) {
  visit_expr(x->a);
  visit_expr(x->b);
}
void Visitor::visit_expr_(const ExprEqRef& x) {
  visit_expr(x->a);
  visit_expr(x->b);
}
void Visitor::visit_expr_(const ExprTypeCastRef& x) {
  visit_expr(x->src);
}

void Visitor::visit_stmt_(const StmtNopRef& x) {
}
void Visitor::visit_stmt_(const StmtBlockRef& x) {
  for (const auto& x : x->stmts) { visit_stmt(x); }
}
void Visitor::visit_stmt_(const StmtConditionalBranchRef& x) {
  visit_stmt(x->then_block);
  visit_stmt(x->else_block);
}
void Visitor::visit_stmt_(const StmtIfThenElseRef& x) {
  visit_stmt(x->body_block);
}
void Visitor::visit_stmt_(const StmtLoopRef& x) {
  visit_stmt(x->body_block);
  visit_stmt(x->continue_block);
}
void Visitor::visit_stmt_(const StmtReturnRef& x) {
}
void Visitor::visit_stmt_(const StmtIfThenElseMergeRef& x) {
}
void Visitor::visit_stmt_(const StmtLoopMergeRef& x) {
}
void Visitor::visit_stmt_(const StmtLoopContinueRef& x) {
}
void Visitor::visit_stmt_(const StmtLoopBackEdgeRef& x) {
}
void Visitor::visit_stmt_(const StmtRangedLoopRef& x) {
  visit_stmt(x->body_block);
}
void Visitor::visit_stmt_(const StmtStoreRef& x) {
}

MemoryRef Mutator::mutate_mem_(MemoryFunctionVariableRef& x) {
  return x;
}
MemoryRef Mutator::mutate_mem_(MemoryIterationVariableRef& x) {
  x->begin = mutate_expr(x->begin);
  x->end = mutate_expr(x->end);
  x->stride = mutate_expr(x->stride);
  return x;
}
MemoryRef Mutator::mutate_mem_(MemoryUniformBufferRef& x) {
  return x;
}
MemoryRef Mutator::mutate_mem_(MemoryStorageBufferRef& x) {
  return x;
}
MemoryRef Mutator::mutate_mem_(MemorySampledImageRef& x) {
  return x;
}
MemoryRef Mutator::mutate_mem_(MemoryStorageImageRef& x) {
  return x;
}

TypeRef Mutator::mutate_ty_(TypeVoidRef& x) {
  return x;
}
TypeRef Mutator::mutate_ty_(TypeBoolRef& x) {
  return x;
}
TypeRef Mutator::mutate_ty_(TypeIntRef& x) {
  return x;
}
TypeRef Mutator::mutate_ty_(TypeFloatRef& x) {
  return x;
}
TypeRef Mutator::mutate_ty_(TypeStructRef& x) {
  for (auto& x : x->members) { x = mutate_ty(x); }
  return x;
}
TypeRef Mutator::mutate_ty_(TypePointerRef& x) {
  x->inner = mutate_ty(x->inner);
  return x;
}

ExprRef Mutator::mutate_expr_(ExprConstantRef& x) {
  return x;
}
ExprRef Mutator::mutate_expr_(ExprLoadRef& x) {
  x->src_ptr = mutate_mem(x->src_ptr);
  return x;
}
ExprRef Mutator::mutate_expr_(ExprAddRef& x) {
  x->a = mutate_expr(x->a);
  x->b = mutate_expr(x->b);
  return x;
}
ExprRef Mutator::mutate_expr_(ExprSubRef& x) {
  x->a = mutate_expr(x->a);
  x->b = mutate_expr(x->b);
  return x;
}
ExprRef Mutator::mutate_expr_(ExprLtRef& x) {
  x->a = mutate_expr(x->a);
  x->b = mutate_expr(x->b);
  return x;
}
ExprRef Mutator::mutate_expr_(ExprEqRef& x) {
  x->a = mutate_expr(x->a);
  x->b = mutate_expr(x->b);
  return x;
}
ExprRef Mutator::mutate_expr_(ExprTypeCastRef& x) {
  x->src = mutate_expr(x->src);
  return x;
}

StmtRef Mutator::mutate_stmt_(StmtNopRef& x) {
  return x;
}
StmtRef Mutator::mutate_stmt_(StmtBlockRef& x) {
  for (auto& x : x->stmts) { x = mutate_stmt(x); }
  return x;
}
StmtRef Mutator::mutate_stmt_(StmtConditionalBranchRef& x) {
  x->cond = mutate_expr(x->cond);
  x->then_block = mutate_stmt(x->then_block);
  x->else_block = mutate_stmt(x->else_block);
  return x;
}
StmtRef Mutator::mutate_stmt_(StmtIfThenElseRef& x) {
  x->body_block = mutate_stmt(x->body_block);
  return x;
}
StmtRef Mutator::mutate_stmt_(StmtLoopRef& x) {
  x->body_block = mutate_stmt(x->body_block);
  x->continue_block = mutate_stmt(x->continue_block);
  return x;
}
StmtRef Mutator::mutate_stmt_(StmtReturnRef& x) {
  return x;
}
StmtRef Mutator::mutate_stmt_(StmtIfThenElseMergeRef& x) {
  return x;
}
StmtRef Mutator::mutate_stmt_(StmtLoopMergeRef& x) {
  return x;
}
StmtRef Mutator::mutate_stmt_(StmtLoopContinueRef& x) {
  return x;
}
StmtRef Mutator::mutate_stmt_(StmtLoopBackEdgeRef& x) {
  return x;
}
StmtRef Mutator::mutate_stmt_(StmtRangedLoopRef& x) {
  x->body_block = mutate_stmt(x->body_block);
  x->itervar = mutate_mem(x->itervar);
  x->begin = mutate_expr(x->begin);
  x->end = mutate_expr(x->end);
  x->stride = mutate_expr(x->stride);
  return x;
}
StmtRef Mutator::mutate_stmt_(StmtStoreRef& x) {
  x->dst_ptr = mutate_mem(x->dst_ptr);
  x->value = mutate_expr(x->value);
  return x;
}
