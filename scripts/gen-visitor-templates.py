"""
Generate visitor templates for tree-like types.
@PENGUINLIONG
"""

from typing import List

from pytest import param

class Name:
    def __init__(self, s):
        """Input `s` is in snake case."""
        self.segs = s.split('_')
    def to_spinal_case(self):
        return '-'.join(x.lower() for x in self.segs)
    def to_snake_case(self):
        return '_'.join(x.lower() for x in self.segs)
    def to_screaming_snake_case(self):
        return '_'.join(x.upper() for x in self.segs)
    def to_pascal_case(self):
        return ''.join(x.title() for x in self.segs)

class NodeFieldType:
    def __init__(self, ty):
        is_plural = ty.endswith("[]")
        is_ref_ty = ty[0].isupper()

        if is_plural:
            ty = ty[:-2]
            if is_ref_ty:
                self.field_ty = f"std::vector<std::shared_ptr<{ty}>>"
                self.param_ty = f"const std::vector<std::shared_ptr<{ty}>>&"
            else:
                self.field_ty = f"std::vector<{ty}>"
                self.param_ty = f"std::vector<{ty}>"
        else:
            if is_ref_ty:
                self.field_ty = f"std::shared_ptr<{ty}>"
                self.param_ty = f"const std::shared_ptr<{ty}>&"
            else:
                self.field_ty = f"{ty}"
                self.param_ty = f"{ty}"

        self.raw_name = ty
        self.is_ref_ty = is_ref_ty
        self.is_plural = is_plural

class NodeField:
    def __init__(self, name, ty: NodeFieldType):
        self.name = Name(name)
        self.ty = ty

class NodeSubtype:
    def __init__(self, name, fields: List[NodeField]):
        self.name = Name(name)
        self.fields = fields

class NodeVariant:
    def __init__(self, formal_name, ty_name, ty_abbr, enum_name, enum_abbr, fields: List[NodeField], subtys: List[NodeSubtype]):
        self.formal_name = formal_name
        self.ty_name = Name(ty_name)
        self.ty_abbr = Name(ty_abbr)
        self.enum_name = Name(enum_name)
        self.enum_abbr = Name(enum_abbr)
        self.fields = fields
        self.subtys = subtys



def json2nova(json) -> NodeVariant:
    formal_name = json["formal_name"]
    ty_name = json["ty_name"]
    ty_abbr = json["ty_abbr"]
    enum_name = json["enum_name"]
    enum_abbr = json["enum_abbr"]
    variants = json["variants"]

    common_fields = [NodeField(name, NodeFieldType(ty)) for name, ty in json["fields"].items()]

    subtys = []
    for name, variant in variants.items():
        fields = [NodeField(name, NodeFieldType(ty)) for name, ty in variant["fields"].items()]
        subtys += [NodeSubtype(name, fields)]

    out = NodeVariant(formal_name, ty_name, ty_abbr, enum_name, enum_abbr, common_fields, subtys)
    return out





def extract_enum(line, prefix):
    line = line.strip()
    if not line.startswith(prefix):
        return None
    return line[len(prefix):-1]

def extract_enums_from_file(src_path, prefix):
    out = []
    with open(src_path) as f:
        out = [extract_enum(x, prefix) for x in f.readlines()]
        out = [NodeSubtype(x) for x in out if x != None]
    return out

def compose_general_header(nova: NodeVariant, desc_appendix):
    desc = f"{nova.formal_name} {desc_appendix}."
    return [
        "// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.",
        f"// {desc}",
        "// @PENGUINLIONG",
        "#pragma once",
    ]
def compose_subty_refs(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    out = [
        f"typedef std::shared_ptr<{ty_prefix}> {ty_prefix}Ref;",
    ]
    for subty in nova.subtys:
        subty_prefix = subty.name.to_pascal_case()
        out += [
            f"typedef std::shared_ptr<{ty_prefix}{subty_prefix}> {ty_prefix}{subty_prefix}Ref;",
        ]
    out += [
        "",
    ]
    return out
def compose_visitor(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    enum_prefix = "L_" + nova.ty_name.to_screaming_snake_case() + "_" + nova.enum_name.to_screaming_snake_case() + "_"
    abbr = nova.ty_abbr.to_snake_case()
    enum_var_name = nova.enum_abbr.to_snake_case()
    out = [
        f"struct {ty_prefix}Visitor {{",
        f"  virtual void visit_{abbr}(const {ty_prefix}Ref& {abbr}) {{",
        f"    switch ({abbr}->{enum_var_name}) {{",
    ]
    for x in nova.subtys:
        out += [
            f"    case {enum_prefix}{x.name.to_screaming_snake_case()}: visit_{abbr}_(std::static_pointer_cast<{ty_prefix}{x.name.to_pascal_case()}>({abbr})); break;",
        ]
    out += [
        "    default: liong::unreachable();",
        "    }",
        "  }",
    ]
    for x in nova.subtys:
        out += [
            f"  virtual void visit_{abbr}_(const {ty_prefix}{x.name.to_pascal_case()}Ref&);",
        ]
    out += [
        "};",
        "",
    ]
    return out
def compose_functor_visitor(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    abbr = nova.ty_abbr.to_snake_case()
    out = [
        f"template<typename T{ty_prefix}>",
        f"struct {ty_prefix}FunctorVisitor : public {ty_prefix}Visitor {{",
        f"  std::function<void(const std::shared_ptr<T{ty_prefix}>&)> f;",
        f"  {ty_prefix}FunctorVisitor(std::function<void(const std::shared_ptr<T{ty_prefix}>&)>&& f) :",
        f"    f(std::forward<std::function<void(const std::shared_ptr<T{ty_prefix}>&)>>(f)) {{}}",
        "",
        f"  virtual void visit_{abbr}_(const std::shared_ptr<T{ty_prefix}>& {abbr}) override final {{",
        f"    f({abbr});",
        "  }",
        "};",
        f"template<typename T{ty_prefix}>",
        f"void visit_{abbr}_functor(",
        f"  std::function<void(const std::shared_ptr<T{ty_prefix}>&)>&& f,",
        f"  const std::shared_ptr<{ty_prefix}>& x",
        ") {",
        f"  {ty_prefix}FunctorVisitor<T{ty_prefix}> visitor(",
        f"    std::forward<std::function<void(const std::shared_ptr<T{ty_prefix}>&)>>(f));",
        f"  visitor.visit_{abbr}(x);",
        "}",
        "",
    ]
    return out
def compose_mutator(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    enum_prefix = "L_" + nova.ty_name.to_screaming_snake_case() + "_" + nova.enum_name.to_screaming_snake_case() + "_"
    abbr = nova.ty_abbr.to_snake_case()
    enum_fields = nova.enum_abbr.to_snake_case()
    ty_ref_prefix = ty_prefix + "Ref"
    out = [
        f"struct {ty_prefix}Mutator {{",
        f"  virtual {ty_ref_prefix} mutate_{abbr}({ty_ref_prefix}& {abbr}) {{",
        f"    switch ({abbr}->{enum_fields}) {{",
    ]
    for x in nova.subtys:
        out += [
            f"    case {enum_prefix}{x.name.to_screaming_snake_case()}: return mutate_{abbr}_(std::static_pointer_cast<{ty_prefix}{x.name.to_pascal_case()}>({abbr}));",
        ]
    out += [
        "    default: liong::unreachable();",
        "    }",
        "  }",
    ]
    for x in nova.subtys:
        out += [
            f"  virtual {ty_ref_prefix} mutate_{abbr}_(std::shared_ptr<{ty_prefix}{x.name.to_pascal_case()}>&);",
        ]
    out += [
        "};",
        "",
    ]
    return out
def compose_functor_mutator(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    abbr = nova.ty_abbr.to_snake_case()
    ty_ref_prefix = ty_prefix + "Ref"
    out = [
        f"template<typename T{ty_prefix}>",
        f"struct {ty_prefix}FunctorMutator : public {ty_prefix}Mutator {{",
        f"  typedef std::shared_ptr<T{ty_prefix}> TStmtRef;",
        f"  std::function<{ty_ref_prefix}(TStmtRef&)> f;",
        f"  {ty_prefix}FunctorMutator(std::function<{ty_ref_prefix}(TStmtRef&)>&& f) :",
        f"    f(std::forward<std::function<{ty_ref_prefix}(TStmtRef&)>>(f)) {{}}",
        "",
        f"  virtual {ty_ref_prefix} mutate_{abbr}_(TStmtRef& {abbr}) override final {{",
        f"    return f({abbr});",
        "  }",
        "};",
        f"template<typename T{ty_prefix}>",
        f"void mutate_{abbr}_functor(",
        f"  std::function<{ty_ref_prefix}(std::shared_ptr<T{ty_prefix}>&)>&& f,",
        f"  const {ty_prefix}& x",
        ") {",
        f"  {ty_prefix}FunctorMutator<T{ty_prefix}> mutator(",
        f"    std::forward<std::function<{ty_ref_prefix}(std::shared_ptr<T{ty_prefix}>&)>>(f));",
        f"  return mutator.mutate_{abbr}(x);",
        "}",
        "",
    ]
    return out

def compose_visitor_hpp(nova: NodeVariant):
    out = compose_general_header(nova, "node visitor") + \
        [ f'#include "node/gen/{nova.ty_abbr.to_spinal_case()}.hpp"', "" ] + \
        compose_subty_refs(nova) + \
        compose_visitor(nova) + \
        compose_functor_visitor(nova) + \
        compose_mutator(nova) + \
        compose_functor_mutator(nova) 
    with open(f"./include/visitor/gen/{nova.ty_abbr.to_spinal_case()}-visitor.hpp", "w") as f:
        f.write('\n'.join(out))


def compose_enum_reg(nova: NodeVariant):
    enum_name = f"{nova.ty_name.to_pascal_case()}{nova.enum_name.to_pascal_case()}"
    enum_case_prefix = f"L_{nova.ty_name.to_screaming_snake_case()}_{nova.enum_name.to_screaming_snake_case()}_"
    out = [
        f"enum {enum_name} {{",
    ]
    for x in nova.subtys:
        out += [
            f"  {enum_case_prefix}{x.name.to_screaming_snake_case()},"
        ]
    out += [
        "};",
        "",
    ]
    return out
def compose_node_ty_declr(nova: NodeVariant):
    ty_name = nova.ty_name.to_pascal_case()
    enum_name = ty_name + nova.enum_name.to_pascal_case()
    enum_var_name = nova.enum_abbr.to_snake_case()
    out = [
        f"struct {ty_name} : public Node {{",
        f"  const {enum_name} {enum_var_name};",
    ]
    for field in nova.fields:
        out += [
            f"  {field.ty.field_ty} {field.name.to_snake_case()};"
        ]
    out += [
        "",
        "  template<typename T>",
        "  const T& as() const {",
        f'    liong::assert(is<T>(), "{nova.formal_name.lower()} {nova.enum_name.to_spinal_case()} mismatched");',
        "    return *(const T*)this;",
        "  }",
        "  template<typename T>",
        "  bool is() const {",
        f"    return {enum_var_name} == T::{nova.enum_abbr.to_screaming_snake_case()};",
        "  }",
        "",
        "protected:",
        f"  inline {ty_name}(",
        f"    {enum_name} {enum_var_name}",
    ]
    for field in nova.fields:
        out[-1] += ","
        out += [
            f"    {field.ty.param_ty} {field.name.to_snake_case()}",
        ]
    out += [
        f"  ) : Node(L_NODE_VARIANT_{nova.ty_name.to_screaming_snake_case()}), {enum_var_name}({enum_var_name})",
    ]
    for field in nova.fields:
        out[-1] += f", {field.name.to_snake_case()}({field.name.to_snake_case()})"
    out += [
        "  {"
    ]
    for field in nova.fields:
        if field.ty.is_ref_ty:
            if field.ty.is_plural:
                out += [
                    f"    for (const auto& x : {field.name.to_snake_case()}) {{ liong::assert(x != nullptr); }}"
                ]
            else:
                out += [
                    f"    liong::assert({field.name.to_snake_case()} != nullptr);",
                ]
    out += [
        "  }"
        "};",
        "",
    ]
    return out

def compose_reg_hpp(nova: NodeVariant):
    out = compose_general_header(nova, "node registry") + \
        [ f'#include "node/node.hpp"', "" ] + \
        compose_enum_reg(nova) + \
        compose_node_ty_declr(nova)
    with open(f"./include/node/gen/{nova.ty_abbr.to_spinal_case()}-reg.hpp", "w") as f:
        f.write('\n'.join(out))




def compose_node_impls(nova: NodeVariant):
    ty_name = nova.ty_name.to_pascal_case()
    enum_name = ty_name + nova.enum_name.to_pascal_case()
    enum_case_prefix = f"L_{nova.ty_name.to_screaming_snake_case()}_{nova.enum_name.to_screaming_snake_case()}_"
    out = []
    for subty in nova.subtys:
        subty_name = ty_name + subty.name.to_pascal_case()
        out += [
            f"struct {subty_name} : public {ty_name} {{",
            f"  static const {enum_name} {nova.enum_abbr.to_screaming_snake_case()} = {enum_case_prefix}{subty.name.to_screaming_snake_case()};",
        ]
        for field in subty.fields:
            out += [
                f"  {field.ty.field_ty} {field.name.to_snake_case()};", 
            ]
        out += [
            "",
            f"  inline {subty_name}(",
        ]
        for i, field in enumerate(nova.fields + subty.fields):
            if i != 0:
                out[-1] += ","
            out += [
                f"    {field.ty.param_ty} {field.name.to_snake_case()}",
            ]
        common_field_init = ''.join([f", {field.name.to_snake_case()}" for field in nova.fields])
        out += [
            f"  ) : {ty_name}({enum_case_prefix}{subty.name.to_screaming_snake_case()}{common_field_init})",
        ]
        for field in subty.fields:
            out[-1] += f", {field.name.to_snake_case()}({field.name.to_snake_case()})"
        out[-1] += " {"
        for field in subty.fields:
            if field.ty.is_ref_ty:
                if field.ty.is_plural:
                    out += [
                        f"    for (const auto& x : {field.name.to_snake_case()}) {{ liong::assert(x != nullptr); }}"
                    ]
                else:
                    out += [
                        f"    liong::assert({field.name.to_snake_case()} != nullptr);",
                    ]
        out += [
            "  }",
            "};",
            ""
        ]
    return out
def compose_hpp(nova: NodeVariant):
    out = compose_general_header(nova, "node implementation") + \
        [ f'#include "node/reg.hpp"', "" ] + \
        compose_node_impls(nova)
    with open(f"./include/node/gen/{nova.ty_abbr.to_spinal_case()}.hpp", "w") as f:
        f.write('\n'.join(out))


def compose_visitor_default_impl(nova: NodeVariant):
    ty_name = nova.ty_name.to_pascal_case()
    out = []
    for subty in nova.subtys:
        subty_name = ty_name + subty.name.to_pascal_case()
        out += [
            f"void {ty_name}Visitor::visit_{nova.ty_abbr.to_snake_case()}_(const {subty_name}Ref& x) {{",
        ]
        for field in subty.fields:
            if field.ty.raw_name == ty_name:
                if (field.ty.is_plural):
                    out += [
                        f"  for (const auto& x : x->{field.name.to_snake_case()}) {{ visit_{nova.ty_abbr.to_snake_case()}(x); }}",
                    ]
                else:
                    out += [
                        f"  visit_{nova.ty_abbr.to_snake_case()}(x->{field.name.to_snake_case()});",
                    ]
        out += [
            "}",
        ]
    out += [
        ""
    ]
    return out

def compose_mutator_default_impl(nova: NodeVariant):
    ty_name = nova.ty_name.to_pascal_case()
    out = []
    for subty in nova.subtys:
        subty_name = ty_name + subty.name.to_pascal_case()
        out += [
            f"{ty_name}Ref {ty_name}Mutator::mutate_{nova.ty_abbr.to_snake_case()}_({subty_name}Ref& x) {{",
        ]
        for field in subty.fields:
            if field.ty.raw_name == ty_name:
                if (field.ty.is_plural):
                    out += [
                        f"  for (auto& x : x->{field.name.to_snake_case()}) {{ x = mutate_{nova.ty_abbr.to_snake_case()}(x); }}",
                    ]
                else:
                    out += [
                        f"  x->{field.name.to_snake_case()} = mutate_{nova.ty_abbr.to_snake_case()}(x->{field.name.to_snake_case()});",
                    ]
        out += [
            "  return x;",
            "}",
        ]
    out += [
        ""
    ]
    return out


def compose_visitor_cpp(nova: NodeVariant):
    out = compose_general_header(nova, "node visitor implementation") + \
        [ f'#include "visitor/gen/{nova.ty_abbr.to_spinal_case()}-visitor.hpp"', "" ] + \
        compose_visitor_default_impl(nova) + \
        compose_mutator_default_impl(nova)
    with open(f"./src/visitor/gen/{nova.ty_abbr.to_spinal_case()}-visitor.cpp", "w") as f:
        f.write('\n'.join(out))




MEMS = {
    "formal_name": "Memory",
    "ty_name": "memory",
    "ty_abbr": "mem",
    "enum_name": "class",
    "enum_abbr": "cls",
    "fields": {
        "ty": "Type",
        "ac": "Expr[]",
    },
    "variants": {
        "function_variable": {
            "fields": {
                "handle": "void*",
            }
        },
        "iteration_variable": {
            "fields": {
                "begin": "Expr",
                "end": "Expr",
                "stride": "Expr",
            }
        },
        "uniform_buffer": {
            "fields": {
                "binding": "uint32_t",
                "set": "uint32_t",
            }
        },
        "storage_buffer": {
            "fields": {
                "binding": "uint32_t",
                "set": "uint32_t",
            }
        },
        "sampled_image": {
            "fields": {
                "binding": "uint32_t",
                "set": "uint32_t",
            }
        },
        "storage_image": {
            "fields": {
                "binding": "uint32_t",
                "set": "uint32_t",
            }
        },
    }
}

mem_nova = json2nova(MEMS)
compose_visitor_hpp(mem_nova)
compose_visitor_cpp(mem_nova)
compose_reg_hpp(mem_nova)
compose_hpp(mem_nova)

TYS = {
    "formal_name": "Type",
    "ty_name": "type",
    "ty_abbr": "ty",
    "enum_name": "class",
    "enum_abbr": "cls",
    "fields": {},
    "variants": {
        "void": {
            "fields": {}
        },
        "bool": {
            "fields": {}
        },
        "int": {
            "fields": {
                "nbit": "uint32_t",
                "is_signed": "bool",
            }
        },
        "float": {
            "fields": {
                "nbit": "uint32_t",
            }
        },
        "struct": {
            "fields": {
                "members": "Type[]",
            }
        },
        "pointer": {
            "fields": {
                "inner": "Type",
            }
        }
    }
}

ty_nova = json2nova(TYS)
compose_visitor_hpp(ty_nova)
compose_visitor_cpp(ty_nova)
compose_reg_hpp(ty_nova)
compose_hpp(ty_nova)


EXPRS = {
    "formal_name": "Expression",
    "ty_name": "expr",
    "ty_abbr": "expr",
    "enum_name": "op",
    "enum_abbr": "op",
    "fields": {
        "ty": "Type",
    },
    "variants": {
        "constant": {
            "fields": {
                "lits": "uint32_t[]",
            }
        },
        "load": {
            "fields": {
                "src_ptr": "Memory",
            }
        },
        "add": {
            "fields": {
                "a": "Expr",
                "b": "Expr",
            }
        },
        "sub": {
            "fields": {
                "a": "Expr",
                "b": "Expr",
            }
        },
        "lt": {
            "fields": {
                "a": "Expr",
                "b": "Expr",
            }
        },
        "eq": {
            "fields": {
                "a": "Expr",
                "b": "Expr",
            }
        },
        "type_cast": {
            "fields": {
                "src": "Expr",
            }
        },
    }
}

expr_nova = json2nova(EXPRS)
compose_visitor_hpp(expr_nova)
compose_visitor_cpp(expr_nova)
compose_reg_hpp(expr_nova)
compose_hpp(expr_nova)

STMTS = {
    "formal_name": "Statement",
    "ty_name": "stmt",
    "ty_abbr": "stmt",
    "enum_name": "op",
    "enum_abbr": "op",
    "fields": {},
    "variants": {
        "nop": {
            "fields": {}
        },
        "block": {
            "fields": {
                "stmts": "Stmt[]",
            }
        },
        "conditional_branch": {
            "fields": {
                "cond": "Expr",
                "then_block": "Stmt",
                "else_block": "Stmt",
            }
        },
        "if_then_else": {
            "fields": {
                "body_block": "Stmt",
            }
        },
        "loop": {
            "fields": {
                "body_block": "Stmt",
                "continue_block": "Stmt",
            }
        },
        "return": {
            "fields": {}
        },
        "if_then_else_merge": {
            "fields": {}
        },
        "loop_merge": {
            "fields": {}
        },
        "loop_continue": {
            "fields": {}
        },
        "loop_back_edge": {
            "fields": {}
        },
        "ranged_loop": {
            "fields": {
                "body_block": "Stmt",
                "itervar": "Memory",
                "begin": "Expr",
                "end": "Expr",
                "stride": "Expr",
            }
        },
        "store": {
            "fields": {
                "dst_ptr": "Memory",
                "value": "Expr",
            }
        },
    }
}

stmt_nova = json2nova(STMTS)
compose_visitor_hpp(stmt_nova)
compose_visitor_cpp(stmt_nova)
compose_reg_hpp(stmt_nova)
compose_hpp(stmt_nova)
