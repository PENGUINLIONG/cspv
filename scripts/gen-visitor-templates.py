"""
Generate visitor templates for tree-like types.
@PENGUINLIONG
"""

from typing import List

class Name:
    def __init__(self, s):
        """Input `s` is in snake case."""
        self.segs = s.split('_')
    def to_spinal_case(self):
        return '-'.join(x.lower() for x in self.segs)
    def to_snake_case(self):
        return '_'.join(x.lower() for x in self.segs)
    def to_screaming_snake_case(self):
        return '_'.join(x.upper() for x in self.segs)
    def to_pascal_case(self):
        return ''.join(x.title() for x in self.segs)


class NodeSubtype:
    def __init__(self, subty_name, fields={}):
        self.subty_name = Name(subty_name)
        self.fields = fields

class NodeVariant:
    def __init__(self, formal_name, ty_name, ty_abbr, enum_name, enum_abbr, subtys: List[NodeSubtype]):
        """
        formal_name = Type
        ty_name     = type
        ty_abbr     = ty
        enum_name   = class
        enum_abbr   = cls
        """
        self.formal_name = formal_name
        self.ty_name = Name(ty_name)
        self.ty_abbr = Name(ty_abbr)
        self.enum_name = Name(enum_name)
        self.enum_abbr = Name(enum_abbr)
        self.subtys = subtys


def extract_enum(line, prefix):
    line = line.strip()
    if not line.startswith(prefix):
        return None
    return line[len(prefix):-1]

def extract_enums_from_file(src_path, prefix):
    out = []
    with open(src_path) as f:
        out = [extract_enum(x, prefix) for x in f.readlines()]
        out = [NodeSubtype(x) for x in out if x != None]
    return out

def compose_general_header(nova: NodeVariant):
    abbr = nova.ty_abbr.to_spinal_case()
    desc = nova.formal_name + " node visitor."
    return [
        "// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.",
        f"// {desc}",
        "// @PENGUINLIONG",
        "#pragma once",
        f'#include "spv/{abbr}.hpp"',
        "",
    ]
def compose_visitor(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    enum_prefix = "L_" + nova.ty_name.to_screaming_snake_case() + "_" + nova.enum_name.to_screaming_snake_case() + "_"
    abbr = nova.ty_abbr.to_snake_case()
    enum_fields = nova.enum_abbr.to_snake_case()
    out = [
        f"struct {ty_prefix}Visitor {{",
        f"  virtual void visit_{abbr}(const {ty_prefix}& {abbr}) {{",
        f"    switch ({abbr}.{enum_fields}) {{",
    ]
    for x in nova.subtys:
        out += [
            f"    case {enum_prefix}{x.subty_name.to_screaming_snake_case()}: visit_{abbr}_(*(const {ty_prefix}{x.subty_name.to_pascal_case()}*)&{abbr}); break;",
        ]
    out += [
        "    default: liong::unreachable();",
        "    }",
        "  }",
    ]
    for x in nova.subtys:
        out += [
            f"  virtual void visit_{abbr}_(const {ty_prefix}{x.subty_name.to_pascal_case()}&);",
        ]
    out += [
        "};",
        "",
    ]
    return out
def compose_functor_visitor(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    abbr = nova.ty_abbr.to_snake_case()
    out = [
        f"template<typename T{ty_prefix}>",
        f"struct {ty_prefix}FunctorVisitor : public {ty_prefix}Visitor {{",
        f"  std::function<void(const T{ty_prefix}&)> f;",
        f"  {ty_prefix}FunctorVisitor(std::function<void(const T{ty_prefix}&)>&& f) :",
        f"    f(std::forward<std::function<void(const T{ty_prefix}&)>>(f)) {{}}",
        "",
        f"  virtual void visit_{abbr}_(const T{ty_prefix}& {abbr}) override final {{",
        f"    f({abbr});",
        "  }",
        "};",
        f"template<typename T{ty_prefix}>",
        f"void visit_{abbr}_functor(",
        f"  std::function<void(const T{ty_prefix}&)>&& f,",
        f"  const {ty_prefix}& x",
        ") {",
        f"  {ty_prefix}FunctorVisitor<T{ty_prefix}> visitor(",
        f"    std::forward<std::function<void(const T{ty_prefix}&)>>(f));",
        f"  visitor.visit_{abbr}(x);",
        "}",
        "",
    ]
    return out
def compose_mutator(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    enum_prefix = "L_" + nova.ty_name.to_screaming_snake_case() + "_" + nova.enum_name.to_screaming_snake_case() + "_"
    abbr = nova.ty_abbr.to_snake_case()
    enum_fields = nova.enum_abbr.to_snake_case()
    out = [
        f"struct {ty_prefix}Mutator {{",
        f"  virtual std::shared_ptr<{ty_prefix}> mutate_{abbr}(std::shared_ptr<{ty_prefix}>& {abbr}) {{",
        f"    switch ({abbr}->{enum_fields}) {{",
    ]
    for x in nova.subtys:
        out += [
            f"    case {enum_prefix}{x.subty_name.to_screaming_snake_case()}: return mutate_{abbr}_(std::static_pointer_cast<{ty_prefix}{x.subty_name.to_pascal_case()}>({abbr}));",
        ]
    out += [
        "    default: liong::unreachable();",
        "    }",
        "  }",
    ]
    for x in nova.subtys:
        out += [
            f"  virtual std::shared_ptr<{ty_prefix}> mutate_{abbr}_(std::shared_ptr<{ty_prefix}{x.subty_name.to_pascal_case()}>&);",
        ]
    out += [
        "};",
        "",
    ]
    return out
def compose_functor_mutator(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    abbr = nova.ty_abbr.to_snake_case()
    out = [
        f"template<typename T{ty_prefix}>",
        f"struct {ty_prefix}FunctorMutator : public {ty_prefix}Mutator {{",
        f"  std::function<std::shared_ptr<{ty_prefix}>(std::shared_ptr<T{ty_prefix}>&)> f;",
        f"  {ty_prefix}FunctorMutator(std::function<std::shared_ptr<{ty_prefix}>(std::shared_ptr<T{ty_prefix}>&)>&& f) :",
        f"    f(std::forward<std::function<std::shared_ptr<{ty_prefix}>(std::shared_ptr<T{ty_prefix}>&)>>(f)) {{}}",
        "",
        f"  virtual std::shared_ptr<{ty_prefix}> mutate_{abbr}_(std::shared_ptr<T{ty_prefix}>& {abbr}) override final {{",
        f"    return f({abbr});",
        "  }",
        "};",
        f"template<typename T{ty_prefix}>",
        f"void mutate_{abbr}_functor(",
        f"  std::function<std::shared_ptr<{ty_prefix}>(std::shared_ptr<T{ty_prefix}>&)>&& f,",
        f"  const {ty_prefix}& x",
        ") {",
        f"  {ty_prefix}FunctorMutator<T{ty_prefix}> mutator(",
        f"    std::forward<std::function<std::shared_ptr<{ty_prefix}>(std::shared_ptr<T{ty_prefix}>&)>>(f));",
        f"  return mutator.mutate_{abbr}(x);",
        "}",
        "",
    ]
    return out

MEMS = extract_enums_from_file("./include/spv/mem-reg.hpp", "L_MEMORY_CLASS_")
mem_nova = NodeVariant("Memory", "memory", "mem", "class", "cls", MEMS)
out = compose_general_header(mem_nova) + \
    compose_visitor(mem_nova)
with open("./include/visitor/gen/mem-visitor.hpp", "w") as f:
    f.write('\n'.join(out))

TYS = extract_enums_from_file("./include/spv/ty-reg.hpp", "L_TYPE_CLASS_")
ty_nova = NodeVariant("Type", "type", "ty", "class", "cls", TYS)
out = compose_general_header(ty_nova) + \
    compose_visitor(ty_nova) + \
    compose_functor_visitor(ty_nova)
with open("./include/visitor/gen/ty-visitor.hpp", "w") as f:
    f.write('\n'.join(out))

EXPRS = extract_enums_from_file("./include/spv/expr-reg.hpp", "L_EXPR_OP_")
expr_nova = NodeVariant("Expression", "expr", "expr", "op", "op", EXPRS)
out = compose_general_header(expr_nova) + \
    compose_visitor(expr_nova) + \
    compose_functor_visitor(expr_nova)
with open("./include/visitor/gen/expr-visitor.hpp", "w") as f:
    f.write('\n'.join(out))

STMTS = {
    "block": {
        "fields": {
            "members": "Stmt+",
        }
    },
    "conditional_branch": {
        "fields": {
            "cond": "Expr",
            "then_block": "Stmt",
            "else_block": "Stmt",
        }
    },
    "if_then_else": {
        "fields": {
            "body_block": "Stmt",
        }
    },
    "loop": {
        "fields": {
            "body_block": "Stmt",
        }
    },
    "return": {
        "fields": {}
    },
    "if_then_else_merge": {
        "fields": {}
    },
    "loop_merge": {
        "fields": {}
    },
    "loop_continue": {
        "fields": {}
    },
    "loop_back_edge": {
        "fields": {}
    },
    "ranged_loop": {
        "fields": {
            "body_block": "Stmt",
            "itervar": "Memory",
            "begin": "Expr",
            "end": "Expr",
            "stride": "Expr",
        }
    },
    "store": {
        "fields": {}
    },
}
def json2subty(json):
    out = []
    for name, meta in json.items():
        fields = meta["fields"]
        out += [NodeSubtype(name, fields)]
    return out

STMTS = json2subty(STMTS)
stmt_nova = NodeVariant("Statement", "stmt", "stmt", "op", "op", STMTS)
out = compose_general_header(stmt_nova) + \
    compose_visitor(stmt_nova) + \
    compose_functor_visitor(stmt_nova) + \
    compose_mutator(stmt_nova) + \
    compose_functor_mutator(stmt_nova) 
with open("./include/visitor/gen/stmt-visitor.hpp", "w") as f:
    f.write('\n'.join(out))
