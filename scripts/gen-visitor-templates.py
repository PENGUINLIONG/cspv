"""
Generate visitor templates for tree-like types.
@PENGUINLIONG
"""

def extract_enum(line, prefix):
    line = line.strip()
    if not line.startswith(prefix):
        return None
    return line[len(prefix):-1]

def extract_enums_from_file(src_path, prefix):
    out = []
    with open(src_path) as f:
        out = [extract_enum(x, prefix) for x in f.readlines()]
        out = [x for x in out if x != None]
    return out

def screaming_snake2pascal(name):
    return ''.join([x.title() for x in name.split('_')])

def compose_general_header(abbr, desc):
    return [
        "// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.",
        "// " + desc,
        "// @PENGUINLIONG",
        "#pragma once",
        f'#include "spv/{abbr}.hpp"',
        "",
    ]
def compose_visitor(ty_prefix, enum_prefix, abbr, enum_field, enums):
    """
    For example:
    ty_prefix = Type
    enum_prefix = L_TYPE_CLASS_
    abbr = ty
    enum_field = cls
    enums = ["VOID", "BOOL", ...]
    """
    out = [
        f"struct {ty_prefix}Visitor {{",
        f"  virtual void visit_{abbr}(const {ty_prefix}& {abbr}) {{",
        f"    switch ({abbr}.{enum_field}) {{",
    ]
    for x in enums:
        out += [
            f"    case {enum_prefix}{x}: visit_{abbr}_(*(const {ty_prefix}{screaming_snake2pascal(x)}*)&{abbr}); break;",
        ]
    out += [
        "    default: liong::unreachable();",
        "    }",
        "  }",
    ]
    for x in enums:
        out += [
            f"  virtual void visit_{abbr}_(const {ty_prefix}{screaming_snake2pascal(x)}&);",
        ]
    out += [
        "};",
        "",
    ]
    return out
def compose_functor_visitor(ty_prefix, abbr):
    out = [
        f"template<typename T{ty_prefix}>",
        f"struct {ty_prefix}FunctorVisitor : public {ty_prefix}Visitor {{",
        f"  std::function<void(const T{ty_prefix}&)> f;",
        f"  {ty_prefix}FunctorVisitor(std::function<void(const T{ty_prefix}&)>&& f) :",
        f"    f(std::forward<std::function<void(const T{ty_prefix}&)>>(f)) {{}}",
        "",
        f"  virtual void visit_{abbr}_(const T{ty_prefix}& {abbr}) override final {{",
        f"    f({abbr});",
        "  }",
        "};",
        f"template<typename T{ty_prefix}>",
        f"void visit_{abbr}_functor(",
        f"  std::function<void(const T{ty_prefix}&)>&& f,",
        f"  const {ty_prefix}& x",
        ") {",
        f"  {ty_prefix}FunctorVisitor<T{ty_prefix}> visitor(",
        f"    std::forward<std::function<void(const T{ty_prefix}&)>>(f));",
        f"  visitor.visit_{abbr}(x);",
        "}",
        "",
    ]
    return out

MEMS = extract_enums_from_file("./include/spv/mem-reg.hpp", "L_MEMORY_CLASS_")
out = compose_general_header("mem", "Memory class visitor.") + \
    compose_visitor("Memory", "L_MEMORY_CLASS_", "mem", "cls", MEMS)
with open("./include/visitor/gen/mem-visitor.hpp", "w") as f:
    f.write('\n'.join(out))

TYPES = extract_enums_from_file("./include/spv/type-reg.hpp", "L_TYPE_CLASS_")
out = compose_general_header("type", "Type class visitor.") + \
    compose_visitor("Type", "L_TYPE_CLASS_", "ty", "cls", TYPES) + \
    compose_functor_visitor("Type", "ty")
with open("./include/visitor/gen/type-visitor.hpp", "w") as f:
    f.write('\n'.join(out))

EXPRS = extract_enums_from_file("./include/spv/expr-reg.hpp", "L_EXPR_OP_")
out = compose_general_header("expr", "Expression tree visitor.") + \
    compose_visitor("Expr", "L_EXPR_OP_", "expr", "op", EXPRS) + \
    compose_functor_visitor("Expr", "expr")
with open("./include/visitor/gen/expr-visitor.hpp", "w") as f:
    f.write('\n'.join(out))

STMTS = extract_enums_from_file("./include/spv/stmt-reg.hpp", "L_STMT_OP_")
out = compose_general_header("stmt", "Statement tree visitor.") + \
    compose_visitor("Stmt", "L_STMT_OP_", "stmt", "op", STMTS) + \
    compose_functor_visitor("Stmt", "stmt")
with open("./include/visitor/gen/stmt-visitor.hpp", "w") as f:
    f.write('\n'.join(out))
