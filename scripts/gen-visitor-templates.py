"""
Generate visitor templates for tree-like types.
@PENGUINLIONG
"""

from typing import List

class Name:
    def __init__(self, s):
        """Input `s` is in snake case."""
        self.segs = s.split('_')
    def to_spinal_case(self):
        return '-'.join(x.lower() for x in self.segs)
    def to_snake_case(self):
        return '_'.join(x.lower() for x in self.segs)
    def to_screaming_snake_case(self):
        return '_'.join(x.upper() for x in self.segs)
    def to_pascal_case(self):
        return ''.join(x.title() for x in self.segs)

class NodeFieldType:
    def __init__(self, ty):
        is_plural = ty.endswith("[]")
        is_ref_ty = ty[0].isupper()

        if is_plural:
            ty = ty[:-2]
            if is_ref_ty:
                self.field_ty = f"std::vector<std::shared_ptr<{ty}>>"
                self.param_ty = f"const std::vector<std::shared_ptr<{ty}>>&"
            else:
                self.field_ty = f"std::vector<{ty}>"
                self.param_ty = f"std::vector<{ty}>"
        else:
            if is_ref_ty:
                self.field_ty = f"std::shared_ptr<{ty}>"
                self.param_ty = f"const std::shared_ptr<{ty}>&"
            else:
                self.field_ty = f"{ty}"
                self.param_ty = f"{ty}"

class NodeField:
    def __init__(self, name, ty: NodeFieldType):
        self.name = Name(name)
        self.ty = ty

class NodeSubtype:
    def __init__(self, name, fields: List[NodeField]):
        self.name = Name(name)
        self.fields = fields

class NodeVariant:
    def __init__(self, formal_name, ty_name, ty_abbr, enum_name, enum_abbr, fields: List[NodeField], subtys: List[NodeSubtype]):
        self.formal_name = formal_name
        self.ty_name = Name(ty_name)
        self.ty_abbr = Name(ty_abbr)
        self.enum_name = Name(enum_name)
        self.enum_abbr = Name(enum_abbr)
        self.fields = fields
        self.subtys = subtys



def json2nova(json) -> NodeVariant:
    formal_name = json["formal_name"]
    ty_name = json["ty_name"]
    ty_abbr = json["ty_abbr"]
    enum_name = json["enum_name"]
    enum_abbr = json["enum_abbr"]
    variants = json["variants"]

    common_fields = [NodeField(name, NodeFieldType(ty)) for name, ty in json["fields"].items()]

    subtys = []
    for name, variant in variants.items():
        fields = [NodeField(name, NodeFieldType(ty)) for name, ty in variant["fields"].items()]
        subtys += [NodeSubtype(name, fields)]

    out = NodeVariant(formal_name, ty_name, ty_abbr, enum_name, enum_abbr, common_fields, subtys)
    return out





def extract_enum(line, prefix):
    line = line.strip()
    if not line.startswith(prefix):
        return None
    return line[len(prefix):-1]

def extract_enums_from_file(src_path, prefix):
    out = []
    with open(src_path) as f:
        out = [extract_enum(x, prefix) for x in f.readlines()]
        out = [NodeSubtype(x) for x in out if x != None]
    return out

def compose_general_header(nova: NodeVariant, desc_appendix):
    desc = f"{nova.formal_name} {desc_appendix}."
    return [
        "// GENERATED BY `scripts/gen-visitor-templates.py`; DO NOT MODIFY.",
        f"// {desc}",
        "// @PENGUINLIONG",
        "#pragma once",
    ]
def compose_subty_refs(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    out = [
        f"typedef std::shared_ptr<{ty_prefix}> {ty_prefix}Ref;",
    ]
    for subty in nova.subtys:
        subty_prefix = subty.name.to_pascal_case()
        out += [
            f"typedef std::shared_ptr<{ty_prefix}{subty_prefix}> {ty_prefix}{subty_prefix}Ref;",
        ]
    out += [
        "",
    ]
    return out
def compose_visitor(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    enum_prefix = "L_" + nova.ty_name.to_screaming_snake_case() + "_" + nova.enum_name.to_screaming_snake_case() + "_"
    abbr = nova.ty_abbr.to_snake_case()
    enum_var_name = nova.enum_abbr.to_snake_case()
    out = [
        f"struct {ty_prefix}Visitor {{",
        f"  virtual void visit_{abbr}(const {ty_prefix}& {abbr}) {{",
        f"    switch ({abbr}.{enum_var_name}) {{",
    ]
    for x in nova.subtys:
        out += [
            f"    case {enum_prefix}{x.name.to_screaming_snake_case()}: visit_{abbr}_(*(const {ty_prefix}{x.name.to_pascal_case()}*)&{abbr}); break;",
        ]
    out += [
        "    default: liong::unreachable();",
        "    }",
        "  }",
    ]
    for x in nova.subtys:
        out += [
            f"  virtual void visit_{abbr}_(const {ty_prefix}{x.name.to_pascal_case()}&);",
        ]
    out += [
        "};",
        "",
    ]
    return out
def compose_functor_visitor(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    abbr = nova.ty_abbr.to_snake_case()
    out = [
        f"template<typename T{ty_prefix}>",
        f"struct {ty_prefix}FunctorVisitor : public {ty_prefix}Visitor {{",
        f"  std::function<void(const T{ty_prefix}&)> f;",
        f"  {ty_prefix}FunctorVisitor(std::function<void(const T{ty_prefix}&)>&& f) :",
        f"    f(std::forward<std::function<void(const T{ty_prefix}&)>>(f)) {{}}",
        "",
        f"  virtual void visit_{abbr}_(const T{ty_prefix}& {abbr}) override final {{",
        f"    f({abbr});",
        "  }",
        "};",
        f"template<typename T{ty_prefix}>",
        f"void visit_{abbr}_functor(",
        f"  std::function<void(const T{ty_prefix}&)>&& f,",
        f"  const {ty_prefix}& x",
        ") {",
        f"  {ty_prefix}FunctorVisitor<T{ty_prefix}> visitor(",
        f"    std::forward<std::function<void(const T{ty_prefix}&)>>(f));",
        f"  visitor.visit_{abbr}(x);",
        "}",
        "",
    ]
    return out
def compose_mutator(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    enum_prefix = "L_" + nova.ty_name.to_screaming_snake_case() + "_" + nova.enum_name.to_screaming_snake_case() + "_"
    abbr = nova.ty_abbr.to_snake_case()
    enum_fields = nova.enum_abbr.to_snake_case()
    ty_ref_prefix = ty_prefix + "Ref"
    out = [
        f"struct {ty_prefix}Mutator {{",
        f"  virtual {ty_ref_prefix} mutate_{abbr}({ty_ref_prefix}& {abbr}) {{",
        f"    switch ({abbr}->{enum_fields}) {{",
    ]
    for x in nova.subtys:
        out += [
            f"    case {enum_prefix}{x.name.to_screaming_snake_case()}: return mutate_{abbr}_(std::static_pointer_cast<{ty_prefix}{x.name.to_pascal_case()}>({abbr}));",
        ]
    out += [
        "    default: liong::unreachable();",
        "    }",
        "  }",
    ]
    for x in nova.subtys:
        out += [
            f"  virtual {ty_ref_prefix} mutate_{abbr}_(std::shared_ptr<{ty_prefix}{x.name.to_pascal_case()}>&);",
        ]
    out += [
        "};",
        "",
    ]
    return out
def compose_functor_mutator(nova: NodeVariant):
    ty_prefix = nova.ty_name.to_pascal_case()
    abbr = nova.ty_abbr.to_snake_case()
    ty_ref_prefix = ty_prefix + "Ref"
    out = [
        f"template<typename T{ty_prefix}>",
        f"struct {ty_prefix}FunctorMutator : public {ty_prefix}Mutator {{",
        f"  typedef std::shared_ptr<T{ty_prefix}> TStmtRef;",
        f"  std::function<{ty_ref_prefix}(TStmtRef&)> f;",
        f"  {ty_prefix}FunctorMutator(std::function<{ty_ref_prefix}(TStmtRef&)>&& f) :",
        f"    f(std::forward<std::function<{ty_ref_prefix}(TStmtRef&)>>(f)) {{}}",
        "",
        f"  virtual {ty_ref_prefix} mutate_{abbr}_(TStmtRef& {abbr}) override final {{",
        f"    return f({abbr});",
        "  }",
        "};",
        f"template<typename T{ty_prefix}>",
        f"void mutate_{abbr}_functor(",
        f"  std::function<{ty_ref_prefix}(std::shared_ptr<T{ty_prefix}>&)>&& f,",
        f"  const {ty_prefix}& x",
        ") {",
        f"  {ty_prefix}FunctorMutator<T{ty_prefix}> mutator(",
        f"    std::forward<std::function<{ty_ref_prefix}(std::shared_ptr<T{ty_prefix}>&)>>(f));",
        f"  return mutator.mutate_{abbr}(x);",
        "}",
        "",
    ]
    return out

def compose_visitor_hpp(nova: NodeVariant):
    out = compose_general_header(nova, "node visitor") + \
        [ f'#include "spv/{nova.ty_abbr.to_spinal_case()}.hpp"', "" ] + \
        compose_subty_refs(nova) + \
        compose_visitor(nova) + \
        compose_functor_visitor(nova) + \
        compose_mutator(nova) + \
        compose_functor_mutator(nova) 
    with open(f"./include/visitor/gen/{nova.ty_abbr.to_spinal_case()}-visitor.hpp", "w") as f:
        f.write('\n'.join(out))


def compose_enum_reg(nova: NodeVariant):
    enum_name = f"{nova.ty_name.to_pascal_case()}{nova.enum_name.to_pascal_case()}"
    enum_case_prefix = f"L_{nova.ty_name.to_screaming_snake_case()}_{nova.enum_name.to_screaming_snake_case()}_"
    out = [
        f"enum {enum_name} {{",
    ]
    for x in nova.subtys:
        out += [
            f"  {enum_case_prefix}{x.name.to_screaming_snake_case()},"
        ]
    out += [
        "};",
        "",
    ]
    return out
def compose_node_ty_declr(nova: NodeVariant):
    ty_name = nova.ty_name.to_pascal_case()
    enum_name = ty_name + nova.enum_name.to_pascal_case()
    enum_var_name = nova.enum_abbr.to_snake_case()
    out = [
        f"struct {ty_name} : public Node {{",
        f"  const {enum_name} {enum_var_name};",
    ]
    for field in nova.fields:
        out += [
            f"  {field.ty.field_ty} {field.name.to_snake_case()};"
        ]
    out += [
        "",
        "  template<typename T>",
        "  const T& as() const {",
        f'    liong::assert(is<T>(), "{nova.formal_name.lower()} {nova.enum_name.to_spinal_case()} mismatched");',
        "    return *(const T*)this;",
        "  }",
        "  template<typename T>",
        "  bool is() const {",
        f"    return {enum_var_name} == T::{nova.enum_abbr.to_screaming_snake_case()};",
        "  }",
        "",
        "protected:",
        f"  inline {ty_name}(",
        f"    {enum_name} {enum_var_name}",
    ]
    for field in nova.fields:
        out[-1] += ","
        out += [
            f"    {field.ty.param_ty} {field.name.to_snake_case()}",
        ]
    out += [
        f"  ) : Node(L_NODE_VARIANT_{nova.ty_name.to_screaming_snake_case()}),",
        f"    {enum_var_name}({enum_var_name})",
    ]
    for field in nova.fields:
        out[-1] += ","
        out += [
            f"    {field.name.to_snake_case()}({field.name.to_snake_case()})",
        ]
    out[-1] += " {}"
    out += [
        "};",
        "",
    ]
    return out

def compose_reg_hpp(nova: NodeVariant):
    out = compose_general_header(nova, "node registry") + \
        [ f'#include "node/node.hpp"', "" ] + \
        compose_enum_reg(nova) + \
        compose_node_ty_declr(nova)
    with open(f"./include/node/gen/{nova.ty_abbr.to_spinal_case()}-reg.hpp", "w") as f:
        f.write('\n'.join(out))


MEMS = {
    "formal_name": "Memory",
    "ty_name": "memory",
    "ty_abbr": "mem",
    "enum_name": "class",
    "enum_abbr": "cls",
    "fields": {
        "ty": "Type",
        "ac": "Expr[]",
    },
    "variants": {
        "function_variable": {
            "fields": {
                "handle": "handle",
            }
        },
        "uniform_buffer": {
            "fields": {
                "binding": "uint32_t",
                "set": "uint32_t",
            }
        },
        "storage_buffer": {
            "fields": {
                "binding": "uint32_t",
                "set": "uint32_t",
            }
        },
        "sampled_image": {
            "fields": {
                "binding": "uint32_t",
                "set": "uint32_t",
            }
        },
        "storage_image": {
            "fields": {
                "binding": "uint32_t",
                "set": "uint32_t",
            }
        },
    }
}

mem_nova = json2nova(MEMS)
compose_visitor_hpp(mem_nova)
compose_reg_hpp(mem_nova)

TYS = {
    "formal_name": "Type",
    "ty_name": "type",
    "ty_abbr": "ty",
    "enum_name": "class",
    "enum_abbr": "cls",
    "fields": {},
    "variants": {
        "void": {
            "fields": {}
        },
        "bool": {
            "fields": {}
        },
        "int": {
            "fields": {
                "nbit": "uint32_t",
                "is_signed": "bool",
            }
        },
        "float": {
            "fields": {
                "nbit": "uint32_t",
                "is_signed": "bool",
            }
        },
        "struct": {
            "fields": {
                "members": "Type[]",
            }
        },
        "pointer": {
            "fields": {
                "inner": "Type",
            }
        }
    }
}

ty_nova = json2nova(TYS)
compose_visitor_hpp(ty_nova)
compose_reg_hpp(ty_nova)


EXPRS = {
    "formal_name": "Expression",
    "ty_name": "expr",
    "ty_abbr": "expr",
    "enum_name": "op",
    "enum_abbr": "op",
    "fields": {
        "ty": "Type",
    },
    "variants": {
        "constant": {
            "fields": {
                "lits": "uint32_t[]",
            }
        },
        "load": {
            "fields": {
                "src_ptr": "Memory",
            }
        },
        "add": {
            "fields": {
                "a": "Expr",
                "b": "Expr",
            }
        },
        "sub": {
            "fields": {
                "a": "Expr",
                "b": "Expr",
            }
        },
        "lt": {
            "fields": {
                "a": "Expr",
                "b": "Expr",
            }
        },
        "eq": {
            "fields": {
                "a": "Expr",
                "b": "Expr",
            }
        },
        "type_cast": {
            "fields": {
                "src": "Expr",
            }
        },
    }
}

expr_nova = json2nova(EXPRS)
compose_visitor_hpp(expr_nova)
compose_reg_hpp(expr_nova)

STMTS = {
    "formal_name": "Statement",
    "ty_name": "stmt",
    "ty_abbr": "stmt",
    "enum_name": "op",
    "enum_abbr": "op",
    "fields": {},
    "variants": {
        "block": {
            "fields": {
                "members": "Stmt+",
            }
        },
        "conditional_branch": {
            "fields": {
                "cond": "Expr",
                "then_block": "Stmt",
                "else_block": "Stmt",
            }
        },
        "if_then_else": {
            "fields": {
                "body_block": "Stmt",
            }
        },
        "loop": {
            "fields": {
                "body_block": "Stmt",
            }
        },
        "return": {
            "fields": {}
        },
        "if_then_else_merge": {
            "fields": {}
        },
        "loop_merge": {
            "fields": {}
        },
        "loop_continue": {
            "fields": {}
        },
        "loop_back_edge": {
            "fields": {}
        },
        "ranged_loop": {
            "fields": {
                "body_block": "Stmt",
                "itervar": "Memory",
                "begin": "Expr",
                "end": "Expr",
                "stride": "Expr",
            }
        },
        "store": {
            "fields": {}
        },
    }
}

stmt_nova = json2nova(STMTS)
compose_visitor_hpp(stmt_nova)
compose_reg_hpp(stmt_nova)
